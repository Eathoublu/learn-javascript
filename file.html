error_page  404              /404.html;

在公交车线路改变后，我终于开始尝试着步行下班了。好处是能锻炼身体，坏处就是成为了大自然的“吸尘器”。但是，锻炼身体必须要坚持下来，走路就是一个很好的开始。
——2017/12/27 16:11

明天就是元旦了，新的一年，新的开始。朋友圈里都在晒十八岁的照片，我的十八岁呢？早已经远去。现在的我已经是一个大人了，不会再像小孩子一样，遇事只能无助地哭泣。不说硬话，不做软事，新的一年，找到真正的自己。
——2017/12/31 23：17

新年来第一天上班，倒霉透顶。早上起迟了，急忙坐上公交车。司机师傅开车非常猛，我闭着眼睛在座位上打瞌睡，心中暗喜，觉得车速这么快，肯定不会迟到。结果路上就撞到一辆货车，被赶下公交车后。打了个黑车，钱花了最后还是迟到，真是无语。

——2018/1/2 17:22

宿命之剑有两道刃，一道是我，而另一道则是死亡。
——2018/1/10 18:41

htmloutput
<?php namespace HashOver;

// Copyright (C) 2015-2017 Jacob Barkdull
// This file is part of HashOver.
//
// HashOver is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// HashOver is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with HashOver.  If not, see <http://www.gnu.org/licenses/>.


// Display source code
if (basename ($_SERVER['PHP_SELF']) === basename (__FILE__)) {
	if (isset ($_GET['source'])) {
		header ('Content-type: text/plain; charset=UTF-8');
		exit (file_get_contents (basename (__FILE__)));
	} else {
		exit ('<b>HashOver</b>: This is a class file.');
	}
}

class HTMLOutput
{
	public $setup;
	public $mode;
	public $locale;
	public $avatars;
	public $misc;
	public $cookies;
	public $login;
	public $commentCounts;
	public $pageTitle;
	public $pageURL;
	public $postCommentOn;
	public $popularComments;
	public $comments;

	protected $emphasizedField;
	protected $defaultLoginInputs;

	public function __construct (Setup $setup, array $counts)
	{
		$this->setup = $setup;
		$this->mode = $setup->usage['mode'];
		$this->locale = new Locale ($setup);
		$this->login = new Login ($setup);
		$this->avatars = new Avatars ($setup);
		$this->misc = new Misc ($this->mode);
		$this->cookies = new Cookies ($setup);
		$this->commentCounts = $counts;
		$this->pageTitle = $this->setup->pageTitle;
		$this->pageURL = $this->setup->pageURL;

		if ($this->mode !== 'php') {
			$this->pageTitle = $this->misc->jsEscape ($this->pageTitle);
			$this->pageURL = $this->misc->jsEscape ($this->pageURL);
		}

		// Set the field to emphasize after a failed post
		if (!empty ($_COOKIE['failed-on'])) {
			$this->emphasizedField = $this->cookies->getValue ('failed-on');
		}

		// "Post a comment" locale strings
		$post_comment_on = $this->locale->get ('post-comment-on');
		$this->postCommentOn = $post_comment_on[0];

		// Add optional "on <page title>" to "Post a comment" title
		if ($this->setup->displaysTitle !== false and !empty ($this->pageTitle)) {
			$this->postCommentOn = sprintf ($post_comment_on[1], $this->pageTitle);
		}

		// Create default login inputs elements
		$this->defaultLoginInputs = $this->loginInputs ();
	}

	protected function injectVar ($var)
	{
		// Return variable as JavaScript concatenation statement
		if ($this->mode !== 'php') {
			if (!empty ($var)) {
				return '\' + ' . $var . ' + \'';
			}
		}

		// Return variable normally by default
		return $var;
	}

	// Re-encode a URL
	protected function safeURLEncode ($url)
	{
		return urlencode (urldecode ($url));
	}

	// Creates input elements for user login information
	protected function loginInputs ($permalink = '', $editForm = false, $name = '', $website = '')
	{
		$permalink = !empty ($permalink) ? '-' . $this->injectVar ($permalink) : '';

		// Login input attribute information
		$login_input_attributes = array (
			'name' => array (
				'wrapper-class' => 'hashover-name-input',
				'label-class' => 'hashover-name-label',
				'placeholder' => $this->locale->get ('name'),
				'input-id' => 'hashover-main-name' . $permalink,
				'input-type' => 'text',
				'input-name' => 'name',
				'input-title' => $this->locale->get ('name-tip'),
				'input-value' => $this->misc->makeXSSsafe ($this->login->name)
			),

			'password' => array (
				'wrapper-class' => 'hashover-password-input',
				'label-class' => 'hashover-password-label',
				'placeholder' => $this->locale->get ('password'),
				'input-id' => 'hashover-main-password' . $permalink,
				'input-type' => 'password',
				'input-name' => 'password',
				'input-title' => $this->locale->get ('password-tip'),
				'input-value' => ''
			),

			'email' => array (
				'wrapper-class' => 'hashover-email-input',
				'label-class' => 'hashover-email-label',
				'placeholder' => $this->locale->get ('email'),
				'input-id' => 'hashover-main-email' . $permalink,
				'input-type' => 'email',
				'input-name' => 'email',
				'input-title' => $this->locale->get ('email-tip'),
				'input-value' => $this->misc->makeXSSsafe ($this->login->email)
			),

			'website' => array (
				'wrapper-class' => 'hashover-website-input',
				'label-class' => 'hashover-website-label',
				'placeholder' => $this->locale->get ('website'),
				'input-id' => 'hashover-main-website' . $permalink,
				'input-type' => 'url',
				'input-name' => 'website',
				'input-title' => $this->locale->get ('website-tip'),
				'input-value' => $this->misc->makeXSSsafe ($this->login->website)
			)
		);

		// Change input values to specified values
		if ($editForm === true) {
			$login_input_attributes['name']['input-value'] = $this->injectVar ($name);
			$login_input_attributes['password']['placeholder'] = $this->locale->get ('confirm-password');
			$login_input_attributes['password']['input-title'] = $this->locale->get ('confirm-password');
			$login_input_attributes['website']['input-value'] = $this->injectVar ($website);
		}

		// Create wrapper element for styling login inputs
		$login_inputs = new HTMLTag ('div', array (
			'class' => 'hashover-inputs'
		));

		// Create and append login input elements to main form inputs wrapper element
		foreach ($login_input_attributes as $field => $attributes) {
			// Skip disabled input tags
			if ($this->setup->fieldOptions[$field] === false) {
				continue;
			}

			// Create cell element for inputs
			$input_cell = new HTMLTag ('div', array (
				'class' => 'hashover-input-cell'
			));

			if ($this->setup->usesLabels === true) {
				// Create label element for input
				$label = new HTMLTag ('label', array (
					'for' => $attributes['input-id'],
					'class' => $attributes['label-class'],
					'innerHTML' => $attributes['placeholder']
				), false);

				// Add label to cell element
				$input_cell->appendChild ($label);
			}

			// Create wrapper element for input
			$input_wrapper = new HTMLTag ('div', array (
				'class' => $attributes['wrapper-class']
			));

			// Add a class for indicating a required field
			if ($this->setup->fieldOptions[$field] === 'required') {
				$input_wrapper->appendAttribute ('class', 'hashover-required-input');
			}

			// Add a class for indicating a post failure
			if ($this->emphasizedField === $field) {
				$input_wrapper->appendAttribute ('class', 'hashover-emphasized-input');
			}

			// Create input element
			$input = new HTMLTag ('input', array (
				'id' => $attributes['input-id'],
				'class' => 'hashover-input-info',
				'type' => $attributes['input-type'],
				'name' => $attributes['input-name'],
				'value' => $attributes['input-value'],
				'title' => $attributes['input-title'],
				'placeholder' => $attributes['placeholder']
			), false, true);

			// Add input to wrapper element
			$input_wrapper->appendChild ($input);

			// Add input to cell element
			$input_cell->appendChild ($input_wrapper);

			// Add input cell to main inputs wrapper element
			$login_inputs->appendChild ($input_cell);
		}

		return $login_inputs;
	}

	protected function getAvatarBackground ($avatar_src)
	{
		// Background image CSS
		$background_image = 'background-image: url(\'%s\');';

		// Escape background image in JavaScript mode
		if ($this->mode !== 'php') {
			$background_image = $this->misc->jsEscape ($background_image);
		}

		// Inject avatar URL into background image CSS
		return sprintf ($background_image, $avatar_src);
	}

	protected function avatar ($text)
	{
		// If avatars set to images
		if ($this->setup->iconMode === 'image') {
			// Logged in
			if ($this->login->userIsLoggedIn === true) {
				// Image source is avatar image
				$hash = !empty ($this->login->email) ? md5 (mb_strtolower (trim ($this->login->email))) : '';
				$avatar_src = $this->avatars->getGravatar ($hash);
			} else {
				// Logged out
				// Image source is local default image
				$avatar_src = $this->setup->httpImages . '/first-comment.' . $this->setup->imageFormat;
			}

			// Create avatar image element
			$avatar = new HTMLTag ('div', array (
				'style' => $this->getAvatarBackground ($avatar_src)
			), false);
		} else {
			// Avatars set to count
			// Create element displaying comment number user will be
			$avatar = new HTMLTag ('span', array (
				'innerHTML' => $text
			), false);
		}

		return $avatar;
	}

	// Creates a wrapper element for each comment
	public function commentWrapper ($permalink, $classes = '', $innerHTML = '')
	{
		$comment_wrapper = new HTMLTag ('div', array (
			'id' => $this->injectVar ($permalink),
			'class' => 'hashover-comment',
			'itemscope' => '',
			'itemtype' => 'http://schema.org/UserComments'
		), false);

		if ($this->mode !== 'php') {
			$comment_wrapper->appendAttribute ('class', $this->injectVar ($classes), false);
			$comment_wrapper->innerHTML ($this->injectVar ($innerHTML));

			return $comment_wrapper->asHTML ();
		}

		return $comment_wrapper;
	}

	// Creates wrapper element to name element
	public function nameWrapper ($name_Link, $name_class)
	{
		$name_wrapper = new HTMLTag ('span', array (
			'class' => 'hashover-comment-name ' . $this->injectVar ($name_class),
			'innerHTML' => $this->injectVar ($name_Link)
		), false);

		return $name_wrapper->asHTML ();
	}

	// Creates name hyperlink/span element
	public function nameElement ($element, $name, $permalink, $href = '')
	{
		$name_text = $this->injectVar ($name);
		$name_class = 'hashover-name-' . $this->injectVar ($permalink);

		// Decide what kind of element to create
		switch ($element) {
			case 'a': {
				// A hyperlink pointing to the user's input URL
				$name_link = new HTMLTag ('a', array (
					'href' => $this->injectVar ($href),
					'class' => $name_class,
					'rel' => 'noopener noreferrer',
					'target' => '_blank',
					'title' => $name_text,
					'innerHTML' => $name_text
				), false);

				break;
			}

			case 'span': {
				// A plain wrapper element
				$name_link = new HTMLTag ('span', array (
					'class' => $name_class,
					'innerHTML' => $name_text
				), false);

				break;
			}
		}

		return $name_link->asHTML ();
	}

	// Creates "Top of Thread" hyperlink element
	public function threadLink ($permalink, $parent, $name)
	{
		// Get locale string
		$thread_locale = $this->locale->get ('thread');

		// Inject OP's name into the locale
		$inner_html = sprintf ($thread_locale, $this->injectVar ($name));

		// Create hyperlink element
		$thread_link = new HTMLTag ('a', array (
			'href' => '#' . $this->injectVar ($parent),
			'id' => 'hashover-thread-link-' . $this->injectVar ($permalink),
			'class' => 'hashover-thread-link',
			'title' => $this->locale->get ('thread-tip'),
			'innerHTML' => $inner_html
		), false);

		return $thread_link->asHTML ();
	}

	// Creates hyperlink with URL queries to link reference
	protected function queryLink ($href = '', array $queries = array ())
	{
		$link = new HTMLTag ('a', array ('href' => $href), false);
		$queries = array_merge ($this->setup->URLQueryList, $queries);

		// Add URL queries to link reference
		if (!empty ($queries)) {
			$link->appendAttribute ('href', '?' . implode ('&', $queries), false);
		}

		return $link;
	}

	// Creates date/permalink hyperlink element
	public function dateLink ($permalink, $date)
	{
		// Create hyperlink element
		$date_link = $this->queryLink ($this->setup->filePath);

		// Append more attributes
		$date_link->appendAttributes (array (
			'href' => '#' . $this->injectVar ($permalink),
			'class' => 'hashover-date-permalink',
			'title' => 'Permalink',
			'innerHTML' => $this->injectVar ($date)
		), false);

		return $date_link->asHTML ();
	}

	// Creates element to hold a count of likes/dislikes each comment has
	public function likeCount ($type, $permalink, $text)
	{
		// CSS class
		$class = 'hashover-' . $type;

		// Create element
		$count = new HTMLTag ('span', array (
			'id' => $class . '-' . $this->injectVar ($permalink),
			'class' => $class,
			'innerHTML' => $this->injectVar ($text)
		), false);

		return $count->asHTML ();
	}

	// Creates "Like"/"Dislike" hyperlink element
	public function likeLink ($type, $permalink, $class, $title, $text)
	{
		// Create hyperlink element
		$link = new HTMLTag ('a', array (
			'href' => '#',
			'id' => 'hashover-' . $type . '-' . $this->injectVar ($permalink),
			'class' => $this->injectVar ($class),
			'title' => $this->injectVar ($title),
			'innerHTML' => $this->injectVar ($text)
		), false);

		return $link->asHTML ();
	}

	// Creates a form control hyperlink element
	public function formLink ($type, $permalink, $class = '', $title = '')
	{
		$form = 'hashover-' . $type;
		$permalink = $this->injectVar ($permalink);
		$link = $this->queryLink ('', array ($form . '=' . $permalink));
		$title_locale = ($type === 'reply') ? 'reply-to-comment' : 'edit-your-comment';

		// Create more attributes
		$link->createAttributes (array (
			'id' => $form. '-link-' . $permalink,
			'class' => 'hashover-comment-' . $type,
			'title' => $this->locale->get ($title_locale)
		));

		// Append href attribute
		$link->appendAttribute ('href', '#' . $form . '-' . $permalink, false);

		// Append attributes
		if ($type === 'reply') {
			$link->appendAttributes (array (
				'class' => $this->injectVar ($class),
				'title' => '- ' . $this->injectVar ($title)
			));
		}

		// Add link text
		$link->innerHTML ($this->locale->get ($type));

		return $link->asHTML ();
	}

	// Creates "Cancel" hyperlink element
	public function cancelLink ($permalink, $for, $class = '')
	{
		$cancel_link = $this->queryLink ($this->setup->filePath);
		$cancel_locale = $this->locale->get ('cancel');

		// Append href attribute
		$cancel_link->appendAttribute ('href', '#' . $permalink, false);

		// Create more attributes
		$cancel_link->createAttributes (array (
			'class' => 'hashover-comment-' . $for,
			'title' => $cancel_locale
		));

		// Append optional class
		if (!empty ($class)) {
			$cancel_link->appendAttribute ('class', $class);
		}

		// Add "Cancel" hyperlink text
		$cancel_link->innerHTML ($cancel_locale);

		return $cancel_link->asHTML ();
	}

	public function userAvatar ($text, $href, $src)
	{
		// If avatars set to images
		if ($this->setup->iconMode !== 'none') {
			// Create wrapper element for avatar image
			$avatar_wrapper = new HTMLTag ('span', array (
				'class' => 'hashover-avatar'
			), false);

			if ($this->setup->iconMode === 'image') {
				// Create avatar image element
				$comments_avatar = new HTMLTag ('div', array (
					'style' => $this->getAvatarBackground ($this->injectVar ($src))
				), false);
			} else {
				// Avatars set to count
				// Create element displaying comment number user will be
				$comments_avatar = new HTMLTag ('a', array (
					'href' => '#' . $this->injectVar ($href),
					'title' => 'Permalink',
					'innerHTML' => $this->injectVar ($text)
				), false);
			}

			// Add comments avatar to avatar image wrapper element
			$avatar_wrapper->appendChild ($comments_avatar);

			return $avatar_wrapper->asHTML ();
		}
	}

	protected function subscribeLabel ($id = '', $class = 'main', $checked = true)
	{
		// Create subscribe checkbox label element
		$subscribe_label = new HTMLTag ('label', array (
			'for' => 'hashover-subscribe',
			'class' => 'hashover-' . $class . '-label',
			'title' => $this->locale->get ('subscribe-tip')
		));

		if (!empty ($id)) {
			$subscribe_label->appendAttribute ('for', '-' . $this->injectVar ($id), false);
		}

		// Create subscribe element checkbox
		$subscribe = new HTMLTag ('input', array (
			'id' => 'hashover-subscribe',
			'type' => 'checkbox',
			'name' => 'subscribe'
		), false, true);

		if (!empty ($id)) {
			$subscribe->appendAttribute ('id', '-' . $this->injectVar ($id), false);
		}

		// Check checkbox
		if ($checked === true) {
			$subscribe->createAttribute ('checked', 'true');
		}

		// Add subscribe checkbox element to subscribe checkbox label element
		$subscribe_label->appendChild ($subscribe);

		// Add text to subscribe checkbox label element
		$subscribe_label->appendInnerHTML ($this->locale->get ('subscribe'));

		return $subscribe_label;
	}

	protected function acceptedFormatCell ($format, $locale_key)
	{
		$title = new HTMLTag ('p', array ('class' => 'hashover-title'));
		$accepted_format = sprintf ($this->locale->get ('accepted-format'), $format);
		$title->innerHTML ($accepted_format);

		$paragraph = new HTMLTag ('p');
		$paragraph->innerHTML ($this->locale->get ($locale_key));

		return new HTMLTag ('div', array (
			'children' => array ($title, $paragraph)
		));
	}

	protected function commentForm (HTMLTag $form, $type, $placeholder, $text, $permalink = '')
	{
		$permalink = !empty ($permalink) ? '-' . $this->injectVar ($permalink) : '';
		$title_locale = ($type === 'reply') ? 'reply-form' : 'comment-form';

		// Create textarea
		$textarea = new HTMLTag ('textarea', array (
			'id' => 'hashover-' . $type . '-comment' . $permalink,
			'class' => 'hashover-textarea hashover-' . $type . '-textarea',
			'cols' => '63',
			'name' => 'comment',
			'rows' => '6',
			'title' => $this->locale->get ($title_locale)
		), false);

		// Set the placeholder attribute if one is given
		if (!empty ($placeholder)) {
			$textarea->createAttribute ('placeholder', $placeholder);
		}

		if ($type === 'main') {
			// Add a class for indicating a post failure
			if ($this->emphasizedField === 'comment') {
				$textarea->appendAttribute ('class', 'hashover-emphasized-input');
			}

			// If the comment was a reply, have the textarea use the reply textarea locale
			if (!empty ($_COOKIE['replied'])) {
				$reply_form_placeholder = $this->locale->get ('reply-form');
				$textarea->createAttribute ('placeholder', $reply_form_placeholder);
			}
		}

		// Set textarea content if given any text
		if (!empty ($text)) {
			$textarea->innerHTML ($text);
		}

		// Add textarea element to form element
		$form->appendChild ($textarea);

		// Create element for various messages when needed
		if ($type !== 'main') {
			$message = new HTMLTag ('div', array (
				'id' => 'hashover-' . $type . '-message-container' . $permalink,
				'class' => 'hashover-message',

				'children' => array (
					new HTMLTag ('div', array (
						'id' => 'hashover-' . $type . '-message' . $permalink
					))
				)
			));

			// Add message element to form element
			$form->appendChild ($message);
		}

		// Create accepted HTML message element
		$accepted_html_message = new HTMLTag ('div', array (
			'id' => 'hashover-' . $type . '-formatting-message' . $permalink,
			'class' => 'hashover-formatting-message',

			'children' => array (
				new HTMLTag ('div', array (
					'class' => 'hashover-formatting-table',

					'children' => array (
						$this->acceptedFormatCell ('HTML', 'accepted-html'),
						$this->acceptedFormatCell ('Markdown', 'accepted-markdown')
					)
				))
			)
		));

		// Ensure the accepted HTML message is open in PHP mode
		if ($this->mode === 'php') {
			$accepted_html_message->appendAttribute ('class', 'hashover-message-open');
			$accepted_html_message->appendAttribute ('class', 'hashover-php-message-open');
		}

		// Add accepted HTML message element to form element
		$form->appendChild ($accepted_html_message);
	}

	protected function pageInfoFields (HTMLTag $form)
	{
		// Create hidden page URL input element
		$url_input = new HTMLTag ('input', array (
			'type' => 'hidden',
			'name' => 'url',
			'value' => $this->pageURL
		), false, true);

		// Add hidden page URL input element to form element
		$form->appendChild ($url_input);

		// Create hidden page title input element
		$title_input = new HTMLTag ('input', array (
			'type' => 'hidden',
			'name' => 'title',
			'value' => $this->pageTitle
		), false, true);

		// Add hidden page title input element to form element
		$form->appendChild ($title_input);

		// Check if the script is being remotely accessed
		if ($this->setup->remoteAccess === true) {
			// Create hidden input element indicating remote access
			$remote_access_input = new HTMLTag ('input', array (
				'type' => 'hidden',
				'name' => 'remote-access',
				'value' => 'true'
			), false, true);

			// Add remote access input element to form element
			$form->appendChild ($remote_access_input);
		}
	}

	protected function acceptedHTML ($type, $permalink = '')
	{
		$permalink = !empty ($permalink) ? '-' . $this->injectVar ($permalink) : '';
		$accepted_format = $this->locale->get ('comment-formatting');

		// Create accepted HTML message revealer hyperlink
		$accepted_html = new HTMLTag ('span', array (
			'id' => 'hashover-' . $type . '-formatting' . $permalink,
			'class' => 'hashover-fake-link hashover-formatting',
			'title' => $accepted_format,
			'innerHTML' => $accepted_format
		));

		// Return the hyperlink
		return $accepted_html;
	}

	public function initialHTML (array $popular_list, $hashover_wrapper = true)
	{
		// Create element that HashOver comments will appear in
		$hashover_element = new HTMLTag ('div', array (
			'id' => 'hashover'
		), false);

		// Add class for differentiating desktop and mobile styling
		if ($this->setup->isMobile === true) {
			$hashover_element->appendAttribute ('class', 'hashover-mobile');
		} else {
			$hashover_element->appendAttribute ('class', 'hashover-desktop');
		}

		// Add class to indicate user login status
		if ($this->login->userIsLoggedIn === true) {
			$hashover_element->appendAttribute ('class', 'hashover-logged-in');
		} else {
			$hashover_element->appendAttribute ('class', 'hashover-logged-out');
		}

		// Create element for jump anchor
		$jump_anchor = new HTMLTag ('span', array (
			'id' => 'comments'
		));

		// Add jump anchor to HashOver element
		$hashover_element->appendChild ($jump_anchor);

		// Create primary form wrapper element
		$form_section = new HTMLTag ('div', array (
			'id' => 'hashover-form-section'
		));

		// Hide primary form wrapper if comments are to be initially hidden
		if ($this->mode === 'javascript' and $this->setup->collapsesUI === true) {
			$form_section->createAttribute ('style', 'display: none;');
		}

		// Create element for "Post Comment" title
		$post_title = new HTMLTag ('span', array (
			'class' => array (
				'hashover-title',
				'hashover-main-title',
				'hashover-dashed-title'
			),

			'innerHTML' => $this->postCommentOn
		));

		// Add "Post Comment" element to primary form wrapper
		$form_section->appendChild ($post_title);

		// Create element for various messages when needed
		$message_container = new HTMLTag ('div', array (
			'id' => 'hashover-message-container',
			'class' => 'hashover-title hashover-message'
		));

		// Create element for message text
		$message_element = new HTMLTag ('div', array (
			'id' => 'hashover-message'
		));

		// Check if message cookie is set
		if (!empty ($_COOKIE['message']) or !empty ($_COOKIE['error'])) {
			// If so, set the message element to open in PHP mode
			if ($this->mode === 'php') {
				$message_container->appendAttribute ('class', array (
					'hashover-message-open',
					'hashover-php-message-open'
				));
			}

			// Check if the message is a normal message
			if (!empty ($_COOKIE['message'])) {
				// If so, get an XSS safe version of the message
				$message = $this->misc->makeXSSsafe ($this->cookies->getValue ('message'));
			} else {
				// If not, get an XSS safe version of the error message
				$message = $this->misc->makeXSSsafe ($this->cookies->getValue ('error'));

				// And set a class to the message element indicating an error
				$message_container->appendAttribute ('class', 'hashover-message-error');
			}

			// And put current message into message element
			$message_element->innerHTML ($message);
		}

		// Add message text element to message element
		$message_container->appendChild ($message_element);

		// Add message element to primary form wrapper
		$form_section->appendChild ($message_container);

		// Create main HashOver form
		$main_form = new HTMLTag ('form', array (
			'id' => 'hashover-form',
			'class' => 'hashover-balloon',
			'name' => 'hashover-form',
			'action' => $this->setup->httpScripts . '/postcomments.php',
			'method' => 'post'
		));

		// Create wrapper element for styling inputs
		$main_inputs = new HTMLTag ('div', array (
			'class' => 'hashover-inputs'
		));

		// If avatars are enabled
		if ($this->setup->iconMode !== 'none') {
			// Create avatar element for main HashOver form
			$main_avatar = new HTMLTag ('div', array (
				'class' => 'hashover-avatar-image'
			));

			// Add count element to avatar element
			$main_avatar->appendChild ($this->avatar ($this->commentCounts['primary']));

			// Add avatar element to inputs wrapper element
			$main_inputs->appendChild ($main_avatar);
		}

		// Logged in
		if ($this->login->userIsLoggedIn === true) {
			if (!empty ($this->login->name)) {
				$user_name = $this->misc->makeXSSsafe ($this->login->name);
			} else {
				$user_name = $this->setup->defaultName;
			}

			$user_website = $this->misc->makeXSSsafe ($this->login->website);
			$name_class = 'hashover-name-plain';
			$is_twitter = false;

			// Check if user's name is a Twitter handle
			if ($user_name[0] === '@') {
				$user_name = mb_substr ($user_name, 1);
				$name_class = 'hashover-name-twitter';
				$is_twitter = true;
				$name_length = mb_strlen ($user_name);

				if ($name_length > 1 and $name_length <= 30) {
					if (empty ($user_website)) {
						$user_website = 'http://twitter.com/' . $user_name;
					}
				}
			}

			// Create element for logged user's name
			$main_form_column_spanner = new HTMLTag ('div', array (
				'class' => 'hashover-comment-name hashover-top-name'
			), false);

			// Check if user gave website
			if (!empty ($user_website)) {
				if ($is_twitter === false) {
					$name_class = 'hashover-name-website';
				}

				// Create link to user's website
				$main_form_hyperlink = new HTMLTag ('a', array (
					'href' => $user_website,
					'rel' => 'noopener noreferrer',
					'target' => '_blank',
					'title' => $user_name,
					'innerHTML' => $user_name
				), false);

				// Add username hyperlink to main form column spanner
				$main_form_column_spanner->appendChild ($main_form_hyperlink);
			} else {
				// No website
				$main_form_column_spanner->innerHTML ($user_name);
			}

			// Set classes user's name spanner
			$main_form_column_spanner->appendAttribute ('class', $name_class);

			// Add main form column spanner to inputs wrapper element
			$main_inputs->appendChild ($main_form_column_spanner);
		} else {
			// Logged out
			// Use default login inputs
			$main_inputs->appendInnerHTML ($this->defaultLoginInputs->innerHTML);
		}

		// Add inputs wrapper to form element
		$main_form->appendChild ($main_inputs);

		// Create fake "required fields" element as a SPAM trap
		$required_fields = new HTMLTag ('div', array (
			'id' => 'hashover-requiredFields'
		));

		$fake_fields = array (
			'summary' => 'text',
			'age' => 'hidden',
			'lastname' => 'text',
			'address' => 'text',
			'zip' => 'hidden',
		);

		// Create and append fake input elements to fake required fields
		foreach ($fake_fields as $name => $type) {
			$fake_input = new HTMLTag ('input', array (
				'type' => $type,
				'name' => $name,
				'value' => ''
			), false, true);

			// Add fake summary input element to fake required fields
			$required_fields->appendInnerHTML ($fake_input->asHTML ());
		}

		// Add fake input elements to form element
		$main_form->appendChild ($required_fields);

		// Post button locale
		$post_button = $this->locale->get ('post-button');

		// Create label element for comment textarea
		if ($this->setup->usesLabels === true) {
			$main_comment_label = new HTMLTag ('label', array (
				'for' => 'hashover-main-comment',
				'class' => 'hashover-comment-label',
				'innerHTML' => $post_button
			), false);

			// Add comment label to form element
			$main_form->appendChild ($main_comment_label);
		}

		// Get comment text if a comment cookie is set
		$comment_text = $this->misc->makeXSSsafe ($this->cookies->getValue ('comment'));

		// Comment form placeholder text
		$comment_form = $this->locale->get ('comment-form');

		// Create main textarea element and add it to form element
		$this->commentForm ($main_form, 'main', $comment_form, $comment_text);

		// Add page info fields to main form
		$this->pageInfoFields ($main_form);

		// Check if comment is a failed reply
		if (!empty ($_COOKIE['replied'])) {
			// If so, get the comment being replied to
			$replied = $this->cookies->getValue ('replied');

			// Create hidden reply to input element
			$reply_to_input = new HTMLTag ('input', array (
				'type' => 'hidden',
				'name' => 'reply-to',
				'value' => $this->misc->makeXSSsafe ($replied)
			), false, true);

			// And add hidden reply to input element to form element
			$main_form->appendChild ($reply_to_input);
		}

		// Create wrapper element for main form footer
		$main_form_footer = new HTMLTag ('div', array (
			'class' => 'hashover-form-footer'
		));

		// Create wrapper for form links
		$main_form_links_wrapper = new HTMLTag ('span', array (
			'class' => 'hashover-form-links'
		));

		// Add checkbox label element to main form buttons wrapper element
		if ($this->setup->fieldOptions['email'] !== false) {
			if ($this->login->userIsLoggedIn === false or !empty ($this->login->email)) {
				$main_form_links_wrapper->appendChild ($this->subscribeLabel ());
			}
		}

		// Create and add accepted HTML revealer hyperlink
		// if ($this->mode === 'javascript') {
		// 	$main_form_links_wrapper->appendChild ($this->acceptedHTML ('main'));
		// }

		// Add main form links wrapper to main form footer element
		$main_form_footer->appendChild ($main_form_links_wrapper);

		// Create wrapper for form buttons
		$main_form_buttons_wrapper = new HTMLTag ('span', array (
			'class' => 'hashover-form-buttons'
		));

		// Create "Login" / "Logout" button element
		if ($this->setup->allowsLogin !== false or $this->login->userIsLoggedIn === true) {
			$login_button = new HTMLTag ('input', array (
				'id' => 'hashover-login-button',
				'class' => 'hashover-submit',
				'type' => 'submit'
			), false, true);

			// Check login state
			if ($this->login->userIsLoggedIn === true) {
				// Logged in
				$login_button->appendAttribute ('class', 'hashover-logout');
				$logout_locale = $this->locale->get ('logout');

				// Create logged in attributes
				$login_button->createAttributes (array (
					'name' => 'logout',
					'value' => $logout_locale,
					'title' => $logout_locale
				));
			} else {
				// Logged out
				$login_button->appendAttribute ('class', 'hashover-login');

				// Create logged out attributes
				$login_button->createAttributes (array (
					'name' => 'login',
					'value' => $this->locale->get ('login'),
					'title' => $this->locale->get ('login-tip')
				));
			}

			// Add "Login" / "Logout" element to main form footer element
			$main_form_buttons_wrapper->appendChild ($login_button);
		}

		// Create "Post Comment" button element
		$main_post_button = new HTMLTag ('input', array (
			'id' => 'hashover-post-button',
			'class' => 'hashover-submit hashover-post-button',
			'type' => 'submit',
			'name' => 'post',
			'value' => $post_button,
			'title' => $post_button
		), false, true);

		// Add "Post Comment" element to main form buttons wrapper element
		$main_form_buttons_wrapper->appendChild ($main_post_button);

		// Add main form button wrapper to main form footer element
		$main_form_footer->appendChild ($main_form_buttons_wrapper);

		// Add main form footer to main form element
		$main_form->appendChild ($main_form_footer);

		// Add main form element to primary form wrapper
		$form_section->appendChild ($main_form);

		// Check if form position setting set to 'top'
		if ($this->setup->formPosition !== 'bottom') {
			// Add primary form wrapper to HashOver element
			$hashover_element->appendChild ($form_section);
		}

		if (!empty ($popular_list)) {
			// Create wrapper element for popular comments
			$popular_section = new HTMLTag ('div', array (
				'id' => 'hashover-popular-section'
			), false);

			// Hide popular comments wrapper if comments are to be initially hidden
			if ($this->mode === 'javascript') {
				if ($this->setup->collapsesUI === true or $this->setup->collapseLimit <= 0) {
					$popular_section->createAttribute ('style', 'display: none;');
				}
			}

			// Create wrapper element for popular comments title
			$pop_count_wrapper = new HTMLTag ('div', array (
				'class' => 'hashover-dashed-title'
			));

			// Create element for popular comments title
			$pop_count_element = new HTMLTag ('span', array (
				'class' => 'hashover-title'
			));

			// Add popular comments title text
			$popPlural = (count ($popular_list) !== 1) ? 1 : 0;
			$popular_comments_locale = $this->locale->get ('popular-comments');
			$pop_count_element->innerHTML ($popular_comments_locale[$popPlural]);

			// Add popular comments title element to wrapper element
			$pop_count_wrapper->appendChild ($pop_count_element);

			// Add popular comments title wrapper element to popular comments section
			$popular_section->appendChild ($pop_count_wrapper);

			// Create element for popular comments to appear in
			$popular_comments = new HTMLTag ('div', array (
				'id' => 'hashover-top-comments'
			), false);

			// Add comments to HashOver element
			if (!empty ($this->popularComments)) {
				$popular_comments->innerHTML (trim ($this->popularComments));
			}

			// Add popular comments element to popular comments section
			$popular_section->appendChild ($popular_comments);

			// Add popular comments section to HashOver element
			$hashover_element->appendChild ($popular_section);
		}

		// Create wrapper element for comments
		$comments_section = new HTMLTag ('div', array (
			'id' => 'hashover-comments-section'
		), false);

		// Create wrapper element for comment count and sort dropdown menu
		$count_sort_wrapper = new HTMLTag ('div', array (
			'id' => 'hashover-count-wrapper',
			'class' => 'hashover-count-sort hashover-dashed-title'
		));

		// Create element for comment count
		$count_element = new HTMLTag ('span', array (
			'id' => 'hashover-count'
		));

		// Add comment count to comment count element
		if ($this->commentCounts['total'] > 1) {
			$count_element->innerHTML ($this->commentCounts['show-count']);
		}

		// Add comment count element to wrapper element
		$count_sort_wrapper->appendChild ($count_element);

		// JavaScript mode specific HTML
		if ($this->mode === 'javascript') {
			// Hide wrapper if comments are to be initially hidden
			if ($this->setup->collapsesUI === true) {
				$comments_section->createAttribute ('style', 'display: none;');
			}

			// Hide comment count if collapse limit is set at zero
			if ($this->setup->collapseLimit <= 0 or $this->commentCounts['total'] <= 1) {
				$count_sort_wrapper->createAttribute ('style', 'display: none;');
			}

			if ($this->commentCounts['total'] > 2) {
				// Create wrapper element for sort dropdown menu
				$sort_wrapper = new HTMLTag ('span', array (
					'id' => 'hashover-sort',
					'class' => 'hashover-select-wrapper'
				));

				// Create sort dropdown menu element
				$sort_select = new HTMLTag ('select', array (
					'id' => 'hashover-sort-select',
					'name' => 'sort',
					'size' => '1',
					'title' => $this->locale->get ('sort')
				));

				// Array of select tag sort options
				$sort_options = array (
					array ('value' => 'ascending', 'innerHTML' => $this->locale->get ('sort-ascending')),
					array ('value' => 'descending', 'innerHTML' => $this->locale->get ('sort-descending')),
					array ('value' => 'by-date', 'innerHTML' => $this->locale->get ('sort-by-date')),
					array ('value' => 'by-likes', 'innerHTML' => $this->locale->get ('sort-by-likes')),
					array ('value' => 'by-replies', 'innerHTML' => $this->locale->get ('sort-by-replies')),
					array ('value' => 'by-name', 'innerHTML' => $this->locale->get ('sort-by-name'))
				);

				// Create sort options for sort dropdown menu element
				for ($i = 0, $il = count ($sort_options); $i < $il; $i++) {
					$option = new HTMLTag ('option', array (
						'value' => $sort_options[$i]['value'],
						'innerHTML' => $sort_options[$i]['innerHTML']
					), false);

					// Add sort option element to sort dropdown menu
					$sort_select->appendChild ($option);
				}

				// Create empty option group as spacer
				$spacer_optgroup = new HTMLTag ('optgroup', array (
					'label' => '&nbsp;'
				));

				// Add spacer option group to sort dropdown menu
				$sort_select->appendChild ($spacer_optgroup);

				// Create option group for threaded sort options
				$threaded_optgroup = new HTMLTag ('optgroup', array (
					'label' => $this->locale->get ('sort-threads')
				));

				// Array of select tag threaded sort options
				$threaded_sort_options = array (
					array ('value' => 'threaded-descending', 'innerHTML' => $this->locale->get ('sort-descending')),
					array ('value' => 'threaded-by-date', 'innerHTML' => $this->locale->get ('sort-by-date')),
					array ('value' => 'threaded-by-likes', 'innerHTML' => $this->locale->get ('sort-by-likes')),
					array ('value' => 'by-popularity', 'innerHTML' => $this->locale->get ('sort-by-popularity')),
					array ('value' => 'by-discussion', 'innerHTML' => $this->locale->get ('sort-by-discussion')),
					array ('value' => 'threaded-by-name', 'innerHTML' => $this->locale->get ('sort-by-name'))
				);

				// Create sort options for sort dropdown menu element
				for ($i = 0, $il = count ($threaded_sort_options); $i < $il; $i++) {
					$option = new HTMLTag ('option', array (
						'value' => $threaded_sort_options[$i]['value'],
						'innerHTML' => $threaded_sort_options[$i]['innerHTML']
					), false);

					// Add sort option element to threaded option group
					$threaded_optgroup->appendChild ($option);
				}

				// Add threaded sort options group to sort dropdown menu
				$sort_select->appendChild ($threaded_optgroup);

				// Add sort dropdown menu element to sort wrapper element
				$sort_wrapper->appendChild ($sort_select);

				// Add comment count element to wrapper element
				// $count_sort_wrapper->appendChild ($sort_wrapper);
			}
		}

		// Add comment count and sort dropdown menu wrapper to comments section
		$comments_section->appendChild ($count_sort_wrapper);

		// Create element that will hold the comments
		$sort_div = new HTMLTag ('div', array (
			'id' => 'hashover-sort-div'
		), false);

		// Add comments to HashOver element
		if (!empty ($this->comments)) {
			$sort_div->innerHTML (trim ($this->comments));
		}

		// Add comments element to comments section
		$comments_section->appendChild ($sort_div);

		// Add comments element to HashOver element
		$hashover_element->appendChild ($comments_section);

		// Check if form position setting set to 'bottom'
		if ($this->setup->formPosition === 'bottom') {
			// Add primary form wrapper to HashOver element
			$hashover_element->appendChild ($form_section);
		}

		// Create end links wrapper element
		$end_links_wrapper = new HTMLTag ('div', array (
			'id' => 'hashover-end-links'
		));

		// Hide end links wrapper if comments are to be initially hidden
		if ($this->mode === 'javascript' and $this->setup->collapsesUI === true) {
			$end_links_wrapper->createAttribute ('style', 'display: none;');
		}

		// HashOver Comments hyperlink text
		$homepage_link_text = $this->locale->get ('hashover-comments');

		// Create link back to HashOver homepage (fixme! get a real page!)
		$homepage_link = new HTMLTag ('a', array (
			'href' => 'http://tildehash.com/?page=hashover',
			'id' => 'hashover-home-link',
			'target' => '_blank',
			'title' => $homepage_link_text,
			'innerHTML' => $homepage_link_text
		), false);

		// Add link back to HashOver homepage to end links wrapper element
		$end_links_wrapper->innerHTML ($homepage_link->asHTML () . ' &#8210;');

		// End links array
		$end_links = array ();

		if ($this->commentCounts['total'] > 1) {
			if ($this->setup->displaysRSSLink === true
			    and $this->setup->APIStatus ('rss') !== 'disabled')
			{
				// Create RSS feed link
				$rss_link = new HTMLTag ('a', array (), false);
				$rss_link->createAttribute ('href', $this->setup->httpRoot . '/api/rss.php');
				$rss_link->appendAttribute ('href', '?url=' . $this->safeURLEncode ($this->setup->pageURL), false);

				// RSS Feed hyperlink text
				$rss_link_text = $this->locale->get ('rss-feed');

				$rss_link->createAttributes (array (
					'id' => 'hashover-rss-link',
					'target' => '_blank',
					'title' => $rss_link_text,
					'innerHTML' => $rss_link_text
				));

				// Add RSS hyperlink to end links array
				$end_links[] = $rss_link->asHTML ();
			}
		}

		// Source Code hyperlink text
		$source_link_text = $this->locale->get ('source-code');

		// Create link to HashOver source code (fixme! can be done better)
		$source_link = new HTMLTag ('a', array (
			'href' => $this->setup->httpScripts . '/hashover.php?source',
			'id' => 'hashover-source-link',
			'rel' => 'hashover-source',
			'target' => '_blank',
			'title' => $source_link_text,
			'innerHTML' => $source_link_text
		), false);

		// Add source code hyperlink to end links array
		$end_links[] = $source_link->asHTML ();

		if ($this->mode === 'javascript') {
			// Create link to HashOver JavaScript source code
			$javascript_link = new HTMLTag ('a', array (
				'href' => $this->setup->httpScripts . '/hashover-javascript.php',
				'id' => 'hashover-javascript-link',
				'rel' => 'hashover-javascript',
				'target' => '_blank',
				'title' => 'JavaScript'
			), false);

			// Append attributes
			$javascript_link->appendAttribute ('href', '?url=' . $this->safeURLEncode ($this->setup->pageURL), false);
			$javascript_link->appendAttribute ('href', '&title=' . $this->safeURLEncode ($this->setup->pageTitle), false);

			if (!empty ($_GET['hashover-script'])) {
				$hashover_script = $this->misc->makeXSSsafe ($this->safeURLEncode ($_GET['hashover-script']));
				$javascript_link->appendAttribute ('href', '&hashover-script=' . $hashover_script, false);
			}

			// Add JavaScript code hyperlink text
			$javascript_link->innerHTML ('JavaScript');

			// Add JavaScript hyperlink to end links array
			$end_links[] = $javascript_link->asHTML ();
		}

		// Add end links to end links wrapper element
		$end_links_wrapper->appendInnerHTML (implode (' &middot;' . PHP_EOL, $end_links));

		// Add end links wrapper element to HashOver element
		$hashover_element->appendChild ($end_links_wrapper);

		// Return all HTML with the HashOver wrapper element
		if ($hashover_wrapper === true) {
			return $hashover_element->asHTML ();
		}

		// Return just the HashOver wrapper element's innerHTML
		return $hashover_element->innerHTML;
	}

	public function cancelButton ($type, $permalink)
	{
		$permalink = $this->injectVar ($permalink);
		$cancel_button = $this->queryLink ($this->setup->filePath);
		$class = 'hashover-' . $type . '-cancel';
		$cancel_locale = $this->locale->get ('cancel');

		// Add ID attribute with JavaScript variable single quote break out
		if (!empty ($permalink)) {
			$cancel_button->createAttribute ('id', $class . '-' . $permalink);
		}

		// Append href attribute
		$cancel_button->appendAttribute ('href', '#' . $permalink, false);

		// Create more attributes
		$cancel_button->createAttributes (array (
			'class' => 'hashover-submit ' . $class,
			'title' => $cancel_locale,
			'innerHTML' => $cancel_locale
		));

		return $cancel_button;
	}

	public function replyForm ($permalink = '', $file = '', $subscribed = true)
	{
		// Create HashOver reply form
		$reply_form = new HTMLTag ('div', array (
			'class' => 'hashover-balloon'
		));

		// If avatars are enabled
		if ($this->setup->iconMode !== 'none') {
			// Create avatar element for HashOver reply form
			$reply_avatar = new HTMLTag ('div', array (
				'class' => 'hashover-avatar-image'
			));

			// Add count element to avatar element
			$reply_avatar->appendChild ($this->avatar ('+'));

			// Add avatar element to inputs wrapper element
			$reply_form->appendChild ($reply_avatar);
		}

		// Display default login inputs when logged out
		if ($this->login->userIsLoggedIn === false) {
			$reply_login_inputs = $this->loginInputs ($permalink);
			$reply_form->appendChild ($reply_login_inputs);
		}

		// Create label element for comment textarea
		if ($this->setup->usesLabels === true) {
			$reply_comment_label = new HTMLTag ('label', array (
				'for' => 'hashover-reply-comment-' . $this->injectVar ($permalink),
				'class' => 'hashover-comment-label',
				'innerHTML' => $this->locale->get ('reply-to-comment')
			), false);

			// Add comment label to form element
			$reply_form->appendChild ($reply_comment_label);
		}

		// Reply form locale
		$reply_form_placeholder = $this->locale->get ('reply-form');

		// Create reply textarea element and add it to form element
		$this->commentForm ($reply_form, 'reply', $reply_form_placeholder, '', $permalink);

		// Add page info fields to reply form
		$this->pageInfoFields ($reply_form);

		// Create hidden reply to input element
		if (!empty ($file)) {
			$reply_to_input = new HTMLTag ('input', array (
				'type' => 'hidden',
				'name' => 'reply-to',
				'value' => $this->injectVar ($file)
			), false, true);

			// Add hidden reply to input element to form element
			$reply_form->appendChild ($reply_to_input);
		}

		// Create reply form footer element
		$reply_form_footer = new HTMLTag ('div', array (
			'class' => 'hashover-form-footer'
		));

		// Create wrapper for form links
		$reply_form_links_wrapper = new HTMLTag ('span', array (
			'class' => 'hashover-form-links'
		));

		// Add checkbox label element to reply form footer element
		if ($this->setup->fieldOptions['email'] !== false) {
			if ($this->login->userIsLoggedIn === false or !empty ($this->login->email)) {
				$reply_form_links_wrapper->appendChild ($this->subscribeLabel ($permalink, 'reply', $subscribed));
			}
		}

		// Create and add accepted HTML revealer hyperlink
		// if ($this->mode === 'javascript') {
		// 	$reply_form_links_wrapper->appendChild ($this->acceptedHTML ('reply', $permalink));
		// }

		// Add reply form links wrapper to reply form footer element
		$reply_form_footer->appendChild ($reply_form_links_wrapper);

		// Create wrapper for form buttons
		$reply_form_buttons_wrapper = new HTMLTag ('span', array (
			'class' => 'hashover-form-buttons'
		));

		// Create "Cancel" link element
		if ($this->setup->usesCancelButtons === true) {
			// Add "Cancel" link element to reply form footer element
			$reply_cancel_button = $this->cancelButton ('reply', $permalink);
			$reply_form_buttons_wrapper->appendChild ($reply_cancel_button);
		}

		// Create "Post Comment" button element
		$reply_post_button = new HTMLTag ('input', array (), false, true);

		// Add ID attribute with JavaScript variable single quote break out
		if (!empty ($permalink)) {
			$reply_post_button->createAttribute ('id', 'hashover-reply-post-' . $this->injectVar ($permalink));
		}

		// Post reply locale
		$post_reply = $this->locale->get ('post-reply');

		// Continue with other attributes
		$reply_post_button->createAttributes (array (
			'class' => 'hashover-submit hashover-reply-post',
			'type' => 'submit',
			'name' => 'post',
			'value' => $post_reply,
			'title' => $post_reply
		));

		// Add "Post Comment" element to reply form footer element
		$reply_form_buttons_wrapper->appendChild ($reply_post_button);

		// Add reply form buttons wrapper to reply form footer element
		$reply_form_footer->appendChild ($reply_form_buttons_wrapper);

		// Add reply form footer to reply form element
		$reply_form->appendChild ($reply_form_footer);

		return $reply_form->asHTML ();
	}

	public function editForm ($permalink, $file, $name = '', $website = '', $body, $status = '', $subscribed = true)
	{
		// "Edit Comment" locale string
		$edit_comment = $this->locale->get ('edit-comment');

		// "Save Edit" locale string
		$save_edit = $this->locale->get ('save-edit');

		// "Cancel" locale string
		$cancel_edit = $this->locale->get ('cancel');

		// "Delete" locale string
		$delete_comment = $this->locale->get ('delete');

		// Create wrapper element
		$edit_form = new HTMLTag ('div');

		// Create edit form title element
		$edit_form_title = new HTMLTag ('div', array (
			'class' => 'hashover-title hashover-dashed-title',
			'innerHTML' => $edit_comment
		), false);

		if ($this->login->userIsAdmin === true) {
			// Create status dropdown wrapper element
			$edit_status_wrapper = new HTMLTag ('span', array (
				'class' => 'hashover-edit-status',
				'innerHTML' => $this->locale->get ('status')
			), false);

			// Create select wrapper element
			$edit_status_select_wrapper = new HTMLTag ('span', array (
				'class' => 'hashover-select-wrapper'
			), false);

			// Status dropdown menu options
			$status_options = array (
				'approved' => $this->locale->get ('status-approved'),
				'pending' => $this->locale->get ('status-pending'),
				'deleted' => $this->locale->get ('status-deleted')
			);

			// Create status dropdown menu element
			$edit_status_dropdown = new HTMLTag ('select', array (
				'id' => 'hashover-edit-status-' . $this->injectVar ($permalink),
				'name' => 'status',
				'size' => '1'
			));

			foreach ($status_options as $value => $inner_html) {
				// Create status dropdown menu option element
				$edit_status_option = new HTMLTag ('option', array (
					'value' => $value,
					'innerHTML' => $inner_html
				));

				// Set option as selected if it matches the comment status given
				if ($value === $status) {
					$edit_status_option->createAttribute ('selected', 'true');
				}

				// Add option element to status dropdown menu
				$edit_status_dropdown->appendChild ($edit_status_option);
			}

			// Add status dropdown menu to select wrapper element
			$edit_status_select_wrapper->appendChild ($edit_status_dropdown);

			// Add select wrapper to status dropdown wrapper element
			$edit_status_wrapper->appendChild ($edit_status_select_wrapper);

			// Add status dropdown wrapper to edit form title element
			$edit_form_title->appendChild ($edit_status_wrapper);
		}

		// Append edit form title to edit form wrapper
		$edit_form->appendChild ($edit_form_title);

		// Append default login inputs
		$edit_login_inputs = $this->loginInputs ($permalink, true, $name, $website);
		$edit_form->appendChild ($edit_login_inputs);

		// Create label element for comment textarea
		if ($this->setup->usesLabels === true) {
			$edit_comment_label = new HTMLTag ('label', array (
				'for' => 'hashover-edit-comment-' . $this->injectVar ($permalink),
				'class' => 'hashover-comment-label',
				'innerHTML' => $this->locale->get ('edit-your-comment')
			), false);

			// Add comment label to form element
			$edit_form->appendChild ($edit_comment_label);
		}

		// Comment form placeholder text
		$edit_placeholder = $this->locale->get ('comment-form');

		// Edit form textarea text value
		$edit_body = $this->injectVar ($body);

		// Create edit textarea element and add it to form element
		$this->commentForm ($edit_form, 'edit', $edit_placeholder, $edit_body, $permalink);

		// Add page info fields to edit form
		$this->pageInfoFields ($edit_form);

		// Create hidden comment file input element
		$edit_file_input = new HTMLTag ('input', array (
			'type' => 'hidden',
			'name' => 'file',
			'value' => $this->injectVar ($file)
		), false, true);

		// Add hidden page title input element to form element
		$edit_form->appendChild ($edit_file_input);

		// Create wrapper element for edit form buttons
		$edit_form_footer = new HTMLTag ('div', array (
			'class' => 'hashover-form-footer'
		));

		// Create wrapper for form links
		$edit_form_links_wrapper = new HTMLTag ('span', array (
			'class' => 'hashover-form-links'
		));

		// Add checkbox label element to edit form buttons wrapper element
		if ($this->setup->fieldOptions['email'] !== false) {
			$edit_form_links_wrapper->appendChild ($this->subscribeLabel ($permalink, 'edit', $subscribed));
		}

		// Create and add accepted HTML revealer hyperlink
		// if ($this->mode === 'javascript') {
		// 	$edit_form_links_wrapper->appendChild ($this->acceptedHTML ('edit', $permalink));
		// }

		// Add edit form links wrapper to edit form footer element
		$edit_form_footer->appendChild ($edit_form_links_wrapper);

		// Create wrapper for form buttons
		$edit_form_buttons_wrapper = new HTMLTag ('span', array (
			'class' => 'hashover-form-buttons'
		));

		// Create "Cancel" link element
		if ($this->setup->usesCancelButtons === true) {
			// Add "Cancel" hyperlink element to edit form footer element
			$edit_cancel_button = $this->cancelButton ('edit', $permalink);
			$edit_form_buttons_wrapper->appendChild ($edit_cancel_button);
		}

		// Create "Post Comment" button element
		$save_edit_button = new HTMLTag ('input', array (), false, true);

		// Add ID attribute with JavaScript variable single quote break out
		if (!empty ($permalink)) {
			$save_edit_button->createAttribute ('id', 'hashover-edit-post-' . $this->injectVar ($permalink));
		}

		// Continue with other attributes
		$save_edit_button->createAttributes (array (
			'class' => 'hashover-submit hashover-edit-post',
			'type' => 'submit',
			'name' => 'edit',
			'value' => $save_edit,
			'title' => $save_edit
		));

		// Add "Save Edit" element to edit form footer element
		$edit_form_buttons_wrapper->appendChild ($save_edit_button);

		// Create "Delete" button element
		$delete_button = new HTMLTag ('input', array (), false, true);

		// Add ID attribute with JavaScript variable single quote break out
		if (!empty ($permalink)) {
			$delete_button->createAttribute ('id', 'hashover-edit-delete-' . $this->injectVar ($permalink));
		}

		// Continue with other attributes
		$delete_button->createAttributes (array (
			'class' => 'hashover-submit hashover-edit-delete',
			'type' => 'submit',
			'name' => 'delete',
			'value' => $delete_comment,
			'title' => $delete_comment
		));

		// Add "Delete" element to edit form footer element
		$edit_form_buttons_wrapper->appendChild ($delete_button);

		// Add edit form buttons wrapper to edit form footer element
		$edit_form_footer->appendChild ($edit_form_buttons_wrapper);

		// Add form buttons to edit form element
		$edit_form->appendChild ($edit_form_footer);

		return $edit_form->innerHTML;
	}

	public function asJSVar ($html, $var_name, $indent = "\t")
	{
		// Check if JavaScript minification is enabled
		if ($this->setup->minifiesJavaScript === true and $this->setup->minifyLevel >= 3) {
			// If so, remove whitespace collapsing code to a single line
			$html = str_replace (array ("\t", PHP_EOL), array ('', ' '), $html);
		} else {
			// If not, convert literal tabs to JavaScript tabs
			$html = str_replace ("\t", '\t', $html);
		}

		// Trim newlines from start of end of input HTML
		$html = trim ($html, "\r\n");

		// Split the HTML into an array of lines
		$lines = explode (PHP_EOL, $html);
		$line_count = count ($lines);

		// Initial output HTML
		$var = '';

		if ($line_count > 0) {
			// Variable declaration code line
			$var .= $indent . 'var ' . $var_name . ' = \'' . $lines[0];
			$var .= (($line_count > 1) ? '\n' : '') . '\';' . PHP_EOL;

			// Run through the rest of the lines
			for ($i = 1; $i < $line_count; $i++) {
				// Skip empty lines
				if (trim ($lines[$i]) === '') {
					continue;
				}

				// Append indentation
				$var .= $indent;

				// Append variable concatenation code
				$var .= '    ' . $var_name . ' += \'';

				// Append the current line
				$var .= $lines[$i];

				// And close concatenation code
				$var .= '\n\';' . PHP_EOL;
			}
		}

		return $var;
	}
}

js-mode
<?php namespace HashOver;

// Copyright (C) 2010-2017 Jacob Barkdull
// This file is part of HashOver.
//
// HashOver is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// HashOver is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with HashOver.  If not, see <http://www.gnu.org/licenses/>.


// Display source code
if (basename ($_SERVER['PHP_SELF']) === basename (__FILE__)) {
	if (isset ($_GET['source'])) {
		header ('Content-type: text/plain; charset=UTF-8');
		exit (file_get_contents (basename (__FILE__)));
	} else {
		exit ('<b>HashOver</b>: This isn\'t a standalone file.');
	}
}

// Count according to `$showsReplyCount` setting
$show_number_comments = $hashover->getCommentCount ('show-number-comments');

// Text for "Show X Other Comment(s)" link
if ($hashover->setup->collapsesComments !== false) {
	// Check if at least 1 comment is to be shown
	if ($hashover->setup->collapseLimit >= 1) {
		// If so, use the "Show X Other Comments" locale
		$more_link_locale = $hashover->locale->get ('show-other-comments');

		// Shorter variables
		$total_count = $hashover->readComments->totalCount;
		$collapse_limit = $hashover->setup->collapseLimit;

		// Get number of comments after collapse limit
		$other_count = ($total_count - 1) - $collapse_limit;

		// Subtract deleted comment counts
		if ($hashover->setup->countIncludesDeleted === false) {
			$other_count -= $hashover->readComments->collapsedDeletedCount;
		}

		// Decide if count is pluralized
		$more_link_plural = ($other_count !== 1) ? 1 : 0;
		$more_link_text = $more_link_locale[$more_link_plural];

		// And inject the count into the locale string
		$more_link_text = sprintf ($more_link_text, $other_count);
	} else {
		// If not, show count according to `$showsReplyCount` setting
		$more_link_text = $show_number_comments;
	}
}

// Some short variables (FIXME: this is cosmetic)
$allowsLikes = !!$hashover->setup->allowsLikes;
$allowsDislikes = !!$hashover->setup->allowsDislikes;
$likesOrDislikes = ($allowsLikes or $allowsDislikes);

// Return a boolean as a string
function string_boolean ($boolean, $value = true)
{
	return ($boolean === $value) ? 'true' : 'false';
}

// Return a boolean as a string, preferring true
function string_true ($boolean)
{
	return ($boolean !== false) ? 'true' : 'false';
}

// Encodes JSON, returns output that conforms to coding standard
function js_json ($string, $pretty_print = true, $tabs = 1)
{
	$json_options = 0;
	$search = array ('\\/', "'", '"', "','", '    ', PHP_EOL);
	$replace = array ('/', "\'", "'", "', '", "\t", PHP_EOL . str_repeat ("\t", $tabs));

	// Enable pretty print where possible
	if ($pretty_print !== false and defined ('JSON_PRETTY_PRINT')) {
		$json_options |= JSON_PRETTY_PRINT;
	}

	// Check if Unicode escaping can be disabled
	if (defined ('JSON_UNESCAPED_UNICODE')) {
		// If so, encode string as JSON without Unicode escaping
		$json = json_encode ($string, $json_options | JSON_UNESCAPED_UNICODE);
	} else {
		// If not, encode string as JSON normally
		$json = json_encode ($string, $json_options);

		// And decode Unicode escaped characters
		$json = preg_replace_callback ('/\\\u([0-9a-f]{3,4})/i', function ($groups) {
			return html_entity_decode ('&#x' . $groups[1] . ';');
		}, $json);
	}

	// Conform JSON to coding standard
	$json = str_replace ($search, $replace, $json);

	return $json;
}

// Returns a regular expression in JavaScript syntax
function js_regex ($regex, $strings)
{
	$regex = preg_replace ('/\\\\([0-9]+)/', '$\\1', $regex);

	if ($strings !== true) {
		$regex .= 'g';
	}

	return $regex;
}

// Returns an array of regular expressions in JavaScript syntax
function js_regex_array ($regexes, $strings, $tabs = "\t")
{
	// Convert capturing groups to JavaScript syntax
	for ($i = 0, $il = count ($regexes); $i < $il; $i++) {
		$regexes[$i] = js_regex ($regexes[$i], $strings);
	}

	// Return array as strings in JavaScript syntax
	if ($strings === true) {
		return js_json ($regexes);
	}

	// Join array items as regular expressions
	$js_array = implode (',' . PHP_EOL . $tabs . $tabs, $regexes);

	// Return array in JavaScript syntax
	return '[' . PHP_EOL . $tabs . $tabs .  $js_array . PHP_EOL . $tabs . ']';
}

?>
// @licstart  The following is the entire license notice for the
//  JavaScript code in this page.
//
// Copyright (C) 2010-2017 Jacob Barkdull
// This file is part of HashOver.
//
// HashOver is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// HashOver is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with HashOver.  If not, see <http://www.gnu.org/licenses/>.
//
// @licend  The above is the entire license notice for the
//  JavaScript code in this page.


// Initial HashOver object
var HashOver = {};

// FIXME: This will be split into multiple functions in separate files
HashOver.init = function ()
{
	"use strict";

	var execStart		= Date.now ();
	var httpRoot		= '<?php echo $hashover->misc->jsEscape ($hashover->setup->httpRoot); ?>';
	var URLRegex		= '((http|https|ftp):\/\/[a-z0-9-@:;%_\+.~#?&\/=]+)';
	var URLParts		= window.location.href.split ('#');
	var elementsById	= {};
	var trimRegex		= /^[\r\n]+|[\r\n]+$/g;
	var streamMode		= <?php echo string_boolean ($hashover->setup->replyMode, 'stream'); ?>;
	var streamDepth		= <?php echo $hashover->misc->jsEscape ($hashover->setup->streamDepth); ?>;
	var blockCodeRegex	= <?php echo js_regex ($hashover->markdown->blockCodeRegex, false); ?>;
	var inlineCodeRegex	= <?php echo js_regex ($hashover->markdown->inlineCodeRegex, false); ?>;
	var blockCodeMarker	= /CODE_BLOCK\[([0-9]+)\]/g;
	var inlineCodeMarker	= /CODE_INLINE\[([0-9]+)\]/g;
	var collapsedCount	= 0;
	var collapseLimit	= <?php echo $hashover->misc->jsEscape ($hashover->setup->collapseLimit); ?>;
	var defaultName		= '<?php echo $hashover->misc->jsEscape ($hashover->setup->defaultName); ?>';
	var allowsDislikes	= <?php echo string_true ($allowsDislikes); ?>;
	var allowsLikes		= <?php echo string_true ($allowsLikes); ?>;
	var timeFormat		= <?php echo js_json ($hashover->setup->timeFormat, false); ?>;
	var linkRegex		= new RegExp (URLRegex + '( {0,1})', 'ig');
	var imageRegex		= new RegExp ('\\[img\\]<a.*?>' + URLRegex + '</a>\\[/img\\]', 'ig');
	var imageExtensions	= <?php echo js_json ($hashover->setup->imageTypes, false); ?>;
	var imagePlaceholder	= '<?php echo $hashover->misc->jsEscape ($hashover->setup->httpImages); ?>/place-holder.<?php echo $hashover->misc->jsEscape ($hashover->setup->imageFormat); ?>';
	var codeOpenRegex	= /<code>/i;
	var codeTagRegex	= /(<code>)([\s\S]*?)(<\/code>)/ig;
	var preOpenRegex	= /<pre>/i;
	var preTagRegex		= /(<pre>)([\s\S]*?)(<\/pre>)/ig;
	var lineRegex		= /(?:\r\n|\r|\n)/g;
	var paragraphRegex	= /(?:\r\n|\r|\n){2}/g;
	var serverEOL		= '<?php echo str_replace (array ("\r", "\n"), array ('\r', '\n'), PHP_EOL); ?>';
	var doubleEOL		= serverEOL + serverEOL;
	var codeTagMarkerRegex	= /CODE_TAG\[([0-9]+)\]/g;
	var preTagMarkerRegex	= /PRE_TAG\[([0-9]+)\]/g;
	var messageTimeouts	= {};
	var userIsLoggedIn	= <?php echo string_boolean ($hashover->login->userIsLoggedIn); ?>;
	var primaryCount	= <?php echo $hashover->misc->jsEscape ($hashover->readComments->primaryCount - 1); ?>;
	var totalCount		= <?php echo $hashover->misc->jsEscape ($hashover->readComments->totalCount - 1); ?>;
	var AJAXPost		= null;
	var AJAXEdit		= null;
	var httpScripts		= '<?php echo $hashover->misc->jsEscape ($hashover->setup->httpScripts); ?>';
	var commentStatuses	= ['approved', 'pending', 'deleted'];
	var moreLink		= null;
	var sortDiv		= null;
	var moreDiv		= null;
	var showingMore		= false;
	var pageURL		= '<?php echo $hashover->misc->jsEscape ($hashover->html->pageURL); ?>';
	var threadRegex		= /^(c[0-9r]+)r[0-9\-pop]+$/;
	var appendCSS		= true;
	var themeCSS		= httpRoot + '/themes/<?php echo $hashover->misc->jsEscape ($hashover->setup->theme); ?>/style.css';
	var head		= document.head || document.getElementsByTagName ('head')[0];
	var URLHref		= URLParts[0];
	var HashOverDiv		= document.getElementById ('hashover');
	var hashoverScript	= <?php echo js_json ($hashover->setup->executingScript, false); ?>;
	var deviceType		= '<?php echo $hashover->setup->isMobile === true ? 'mobile' : 'desktop'; ?>';
	var HashOverForm	= null;
	var collapseComments	= <?php echo string_true ($hashover->setup->collapsesComments); ?>;
	var URLHash		= URLParts[1] || '';

	// Array for inline code and code block markers
	var codeMarkers = {
		block: { marks: [], count: 0 },
		inline: { marks: [], count: 0 }
	};

	// Some locales, stored in JavaScript to avoid using a lot of PHP tags
	var locale = {
		cancel:			'<?php echo $hashover->locale->get ('cancel'); ?>',
		dateTime:		<?php echo js_json ($hashover->locale->get ('date-time'), false); ?>,
		dislikeComment:		'<?php echo $hashover->locale->get ('dislike-comment'); ?>',
		dislikedComment:	'<?php echo $hashover->locale->get ('disliked-comment'); ?>',
		disliked:		'<?php echo $hashover->locale->get ('disliked'); ?>',
		dislike:		<?php echo js_json ($hashover->locale->get ('dislike', false), false); ?>,
		email:			'<?php echo $hashover->locale->get ('email'); ?>',
		externalImageTip:	'<?php echo $hashover->locale->get ('external-image-tip'); ?>',
		fieldNeeded:		'<?php echo $hashover->locale->get ('field-needed'); ?>',
		likeComment:		'<?php echo $hashover->locale->get ('like-comment'); ?>',
		likedComment:		'<?php echo $hashover->locale->get ('liked-comment'); ?>',
		liked:			'<?php echo $hashover->locale->get ('liked'); ?>',
		like:			<?php echo js_json ($hashover->locale->get ('like', false), false); ?>,
		name:			'<?php echo $hashover->locale->get ('name'); ?>',
		password:		'<?php echo $hashover->locale->get ('password'); ?>',
		postCommentOn:		'<?php echo $hashover->html->postCommentOn; ?>',
		today:			'<?php echo $hashover->locale->get ('date-today'); ?>',
		unlike:			'<?php echo $hashover->locale->get ('unlike'); ?>',
		website:		'<?php echo $hashover->locale->get ('website'); ?>'
	};

	// Markdown patterns to search for
	var markdownSearch = <?php echo js_regex_array ($hashover->markdown->search, false); ?>;

	// HTML replacements for markdown patterns
	var markdownReplace = <?php echo js_regex_array ($hashover->markdown->replace, true); ?>;

	// Tags that will have their innerHTML trimmed
	var trimTagRegexes = {
		blockquote: {
			test: /<blockquote>/,
			replace: /(<blockquote>)([\s\S]*?)(<\/blockquote>)/ig
		},

		ul: {
			test: /<ul>/,
			replace: /(<ul>)([\s\S]*?)(<\/ul>)/ig
		},

		ol: {
			test: /<ol>/,
			replace: /(<ol>)([\s\S]*?)(<\/ol>)/ig
		}
	};

	// Field options
	var fieldOptions = <?php echo js_json ($hashover->setup->fieldOptions); ?>;

	// Shorthand for Document.getElementById ()
	function getElement (id, force)
	{
		if (force === true) {
			return document.getElementById (id);
		}

		if (!elementsById[id]) {
			elementsById[id] = document.getElementById (id);
		}

		return elementsById[id];
	}

	// Execute callback function if element isn't false
	function ifElement (element, callback)
	{
		if (element = getElement (element, true)) {
			return callback (element);
		}

		return false;
	}

	// Trims leading and trailing newlines from a string
	function EOLTrim (string)
	{
		return string.replace (trimRegex, '');
	}

	// Trims whitespace from an HTML tag's inner HTML
	function tagTrimmer (fullTag, openTag, innerHTML, closeTag)
	{
		return openTag + EOLTrim (innerHTML) + closeTag;
	}

	// Find a comment by its permalink
	function findByPermalink (permalink, comments)
	{
		var comment;

		// Loop through all comments
		for (var i = 0, il = comments.length; i < il; i++) {
			// Return comment if its permalink matches
			if (comments[i].permalink === permalink) {
				return comments[i];
			}

			// Recursively check replies when present
			if (comments[i].replies !== undefined) {
				comment = findByPermalink (permalink, comments[i].replies);

				if (comment !== null) {
					return comment;
				}
			}
		}

		// Otherwise return null
		return null;
	}

	// Returns the permalink of a comment's parent
	function getParentPermalink (permalink, flatten)
	{
		flatten = flatten || false;

		var parent = permalink.split ('r');
		var length = parent.length - 1;

		// Limit depth if in stream mode
		if (streamMode === true && flatten === true) {
			length = Math.min (streamDepth, length);
		}

		// Check if there is a parent after flatten
		if (length > 0) {
			// If so, remove child from permalink
			parent = parent.slice (0, length);

			// Return parent permalink as string
			return parent.join ('r');
		}

		return null;
	}

	// Replaces markdown for inline code with a marker
	function codeReplace (fullTag, first, second, third, display)
	{
		var markName = 'CODE_' + display.toUpperCase ();
		var markCount = codeMarkers[display].count++;
		var codeMarker;

		if (display !== 'block') {
			codeMarker = first + markName + '[' + markCount + ']' + third;
			codeMarkers[display].marks[markCount] = EOLTrim (second);
		} else {
			codeMarker = markName + '[' + markCount + ']';
			codeMarkers[display].marks[markCount] = EOLTrim (first);
		}

		return codeMarker;
	}

	// Parses a string as markdown
	function parseMarkdown (string)
	{
		// Reset marker arrays
		codeMarkers = {
			block: { marks: [], count: 0 },
			inline: { marks: [], count: 0 }
		};

		// Replace code blocks with markers
		string = string.replace (blockCodeRegex, function (fullTag, first, second, third) {
			return codeReplace (fullTag, first, second, third, 'block');
		});

		// Break string into paragraphs
		var paragraphs = string.split (paragraphRegex);

		// Run through each paragraph replacing markdown patterns
		for (var i = 0, il = paragraphs.length; i < il; i++) {
			// Replace code tags with marker text
			paragraphs[i] = paragraphs[i].replace (inlineCodeRegex, function (fullTag, first, second, third) {
				return codeReplace (fullTag, first, second, third, 'inline');
			});

			// Perform each markdown regular expression on the current paragraph
			for (var r = 0, rl = markdownSearch.length; r < rl; r++) {
				// Replace markdown patterns
				paragraphs[i] = paragraphs[i].replace (markdownSearch[r], markdownReplace[r]);
			}

			// Return the original markdown code with HTML replacement
			paragraphs[i] = paragraphs[i].replace (inlineCodeMarker, function (marker, number) {
				return '<code class="hashover-inline">' + codeMarkers.inline.marks[number] + '</code>';
			});
		}

		// Join paragraphs
		string = paragraphs.join (doubleEOL);

		// Replace code block markers with original markdown code
		string = string.replace (blockCodeMarker, function (marker, number) {
			return '<code>' + codeMarkers.block.marks[number] + '</code>';
		});

		return string;
	}

	// Adds properties to an element
	function addProperties (element, properties)
	{
		element = element || document.createElement ('span');
		properties = properties || {};

		// Add each property to element
		for (var property in properties) {
			if (properties.hasOwnProperty (property) === false) {
				continue;
			}

			// If the property is an object add each item to existing property
			if (!!properties[property] && properties[property].constructor === Object) {
				addProperties (element[property], properties[property]);
				continue;
			}

			element[property] = properties[property];
		}

		return element;
	}

	// Create an element with attributes
	function createElement (tagName, attributes)
	{
		tagName = tagName || 'span';
		attributes = attributes || {};

		// Create element
		var element = document.createElement (tagName);

		// Add properties to element
		element = addProperties (element, attributes);

		return element;
	}
<?php if ($hashover->setup->usesUserTimezone !== false): ?>

	// Simple PHP date function port
	function formatDate (format, date)
	{
		format = format || 'DATE_ISO8601';
		date = date || new Date ();

		var dayNames = <?php echo js_json ($hashover->locale->get ('date-day-names'), true, 2); ?>;

		var monthNames = <?php echo js_json ($hashover->locale->get ('date-month-names'), true, 2); ?>;

		var hours = date.getHours ();
		var ampm = (hours >= 12) ? 'pm' : 'am';
		var day = date.getDate ();
		var weekDay = date.getDay ();
		var dayName = dayNames[weekDay];
		var monthIndex = date.getMonth ();
		var monthName = monthNames[monthIndex];
		var hours12 = (hours % 12) ? hours % 12 : 12;
		var minutes = date.getMinutes ();
		var month = monthIndex + 1;
		var offsetHours = (date.getTimezoneOffset() / 60) * 100;
		var offset = ((offsetHours < 1000) ? '0' : '') + offsetHours;
		var offsetColon = offset.match (/[0-9]{2}/g).join (':');
		var offsetPositivity = (offsetHours > 0) ? '-' : '+';
		var seconds = date.getSeconds ();
		var year = date.getFullYear ();
		var formatParts = format.split ('');
		var dateConstant;

		var characters = {
			a: ampm,
			A: ampm.toUpperCase (),
			d: (day < 10) ? '0' + day : day,
			D: dayName.substr (0, 3),
			F: monthName,
			g: hours12,
			G: hours,
			h: (hours12 < 10) ? '0' + hours12 : hours12,
			H: (hours < 10) ? '0' + hours : hours,
			i: (minutes < 10) ? '0' + minutes : minutes,
			j: day,
			l: dayName,
			m: (month < 10) ? '0' + month : month,
			M: monthName.substr (0, 3),
			n: month,
			N: weekDay + 1,
			O: offsetPositivity + offset,
			P: offsetPositivity + offsetColon,
			s: (seconds < 10) ? '0' + seconds : seconds,
			w: weekDay,
			y: ('' + year).substr (2),
			Y: year
		};

		dateConstant = format.replace (/-/g, '_');
		dateConstant = dateConstant.toUpperCase ();

		switch (dateConstant) {
			case 'DATE_ATOM':
			case 'DATE_RFC3339':
			case 'DATE_W3C': {
				format = 'Y-m-d\TH:i:sP';
				break;
			}

			case 'DATE_COOKIE': {
				format = 'l, d-M-Y H:i:s';
				break;
			}

			case 'DATE_ISO8601': {
				format = 'Y-m-d\TH:i:sO';
				break;
			}

			case 'DATE_RFC822':
			case 'DATE_RFC1036': {
				format = 'D, d M y H:i:s O';
				break;
			}

			case 'DATE_RFC850': {
				format = 'l, d-M-y H:i:s';
				break;
			}

			case 'DATE_RFC1123':
			case 'DATE_RFC2822':
			case 'DATE_RSS': {
				format = 'D, d M Y H:i:s O';
				break;
			}

			case 'GNOME_DATE': {
				format = 'D M d, g:i A';
				break;
			}

			case 'US_DATE': {
				format = 'm/d/Y';
				break;
			}

			case 'STANDARD_DATE': {
				format = 'Y-m-d';
				break;
			}

			case '12H_TIME': {
				format = 'g:ia';
				break;
			}

			case '24H_TIME': {
				format = 'H:i';
				break;
			}
		}

		for (var i = 0, c, il = formatParts.length; i < il; i++) {
			if (i > 0 && formatParts[i - 1] === '\\') {
				formatParts[i - 1] = '';
				continue;
			}

			c = formatParts[i];
			formatParts[i] = characters[c] || c;
		}

		return formatParts.join ('');
	}
<?php endif; ?>

	// Add comment content to HTML template
	function parseComment (comment, parent, collapse, sort, method, popular)
	{
		parent = parent || null;
		collapse = collapse || false;
		sort = sort || false;
		method = method || 'ascending';
		popular = popular || false;

		var permalink = comment.permalink;
		var nameClass = 'hashover-name-plain';
		var template = { permalink: permalink };
		var isReply = (parent !== null);
		var parentPermalink;
		var commentDate = comment.date;
		var codeTagCount = 0;
		var codeTags = [];
		var preTagCount = 0;
		var preTags = [];
		var classes = '';
		var replies = '';

		// Text for avatar image alt attribute
		var permatext = permalink.slice (1);
		    permatext = permatext.split ('r');
		    permatext = permatext.pop ();

		// Get parent comment via permalink
		if (isReply === false && permalink.indexOf ('r') > -1) {
			parentPermalink = getParentPermalink (permalink);
			parent = findByPermalink (parentPermalink, PHPContent.comments);
			isReply = (parent !== null);
		}

		// Check if this comment is a popular comment
		if (popular === true) {
			// Remove "-pop" from text for avatar
			permatext = permatext.replace ('-pop', '');
		} else {
			// Check if comment is a reply
			// if (isReply === true) {
			// 	// Check that comments are being sorted
			// 	if (!sort || method === 'ascending') {
			// 		// Append class to indicate comment is a reply
			// 		classes += ' hashover-reply';
			// 	}
			// }
<?php if ($hashover->setup->collapsesComments !== false): ?>

			// Append class to indicate collapsed comment
			if (totalCount > 0) {
				if (collapse === true && collapsedCount >= collapseLimit) {
					classes += ' hashover-hidden';
				} else {
					collapsedCount++;
				}
			}
<?php endif; ?>
		}

		// Add avatar image to template
		template.avatar = '<?php echo $hashover->html->userAvatar ('permatext', 'permalink', 'comment.avatar'); ?>';

		if (comment.notice === undefined) {
			var name = comment.name || defaultName;
			var website = comment.website;
			var isTwitter = false;

			// Check if user's name is a Twitter handle
			if (name.charAt (0) === '@') {
				name = name.slice (1);
				nameClass = 'hashover-name-twitter';
				isTwitter = true;
				var nameLength = name.length;

				// Check if Twitter handle is valid length
				if (nameLength > 1 && nameLength <= 30) {
					// Set website to Twitter profile if a specific website wasn't given
					if (website === undefined) {
						website = 'http://twitter.com/' + name;
					}
				}
			}

			// Check whether user gave a website
			if (website !== undefined) {
				if (isTwitter === false) {
					nameClass = 'hashover-name-website';
				}

				// If so, display name as a hyperlink
				var nameLink = '<?php echo $hashover->html->nameElement ('a', 'name', 'permalink', 'website'); ?>';
			} else {
				// If not, display name as plain text
				var nameLink = '<?php echo $hashover->html->nameElement ('span', 'name', 'permalink'); ?>';
			}

			// Construct thread hyperlink
			if (isReply === true) {
				var parentThread = parent.permalink;
				var parentName = parent.name || defaultName;

				// Add thread parent hyperlink to template
				template['thread-link'] = '<?php echo $hashover->html->threadLink ('permalink', 'parentThread', 'parentName'); ?>';
			}

			if (comment['user-owned'] !== undefined) {
				// Append class to indicate comment is from logged in user
				classes += ' hashover-user-owned';

				// Define "Reply" link with original poster title
				var replyTitle = '<?php echo $hashover->locale->get ('commenter-tip'); ?>';
				var replyClass = 'hashover-no-email';

				// Add "Edit" hyperlink to template
				template['edit-link'] = '<?php echo $hashover->html->formLink ('edit', 'permalink'); ?>';
			} else {
				// Check if commenter is subscribed
				if (comment.subscribed === true) {
					// If so, set subscribed title
					var replyTitle = name + ' <?php echo $hashover->locale->get ('subscribed-tip'); ?>';
					var replyClass = 'hashover-has-email';
				} else{
					// If not, set unsubscribed title
					var replyTitle = name + ' <?php echo $hashover->locale->get ('unsubscribed-tip'); ?>';
					var replyClass = 'hashover-no-email';
				}
<?php if ($allowsLikes !== false): ?>

				// Check whether this comment was liked by the visitor
				if (comment.liked !== undefined) {
					// If so, set various attributes to indicate comment was liked
					var likeClass = 'hashover-liked';
					var likeTitle = locale.likedComment;
					var likeText = locale.liked;
				} else {
					// If not, set various attributes to indicate comment can be liked
					var likeClass = 'hashover-like';
					var likeTitle = locale.likeComment;
					var likeText = locale.like[0];
				}

				// Append class to indicate dislikes are enabled
				if (allowsDislikes === true) {
					likeClass += ' hashover-dislikes-enabled';
				}

				// Add like link to HTML template
				template['like-link'] = '<?php echo $hashover->html->likeLink ('like', 'permalink', 'likeClass', 'likeTitle', 'likeText'); ?>';
<?php endif; ?>
<?php if ($allowsDislikes === true): ?>

				// Check whether this comment was disliked by the visitor
				if (comment.disliked !== undefined) {
					// If so, set various attributes to indicate comment was disliked
					var dislikeClass = 'hashover-disliked';
					var dislikeTitle = locale.dislikedComment;
					var dislikeText = locale.disliked;
				} else {
					// If not, set various attributes to indicate comment can be disliked
					var dislikeClass = 'hashover-dislike';
					var dislikeTitle = locale.dislikeComment;
					var dislikeText = locale.dislike[0];
				}

				// Append class to indicate likes are enabled
				if (allowsLikes === true) {
					dislikeClass += ' hashover-likes-enabled';
				}

				// Add dislike link to HTML template
				template['dislike-link'] = '<?php echo $hashover->html->likeLink ('dislike', 'permalink', 'dislikeClass', 'dislikeTitle', 'dislikeText'); ?>';
<?php endif; ?>
			}

<?php if ($allowsLikes !== false): ?>
			// Get number of likes, append "Like(s)" locale
			if (comment.likes !== undefined) {
				var likeCount = comment.likes + ' ' + locale.like[(comment.likes === 1 ? 0 : 1)];
			}

			// Add like count to HTML template
			template['like-count'] = '<?php echo $hashover->html->likeCount ('likes', 'permalink', '(likeCount || \'\')'); ?>';

<?php endif; ?>
<?php if ($allowsDislikes === true): ?>
			// Get number of dislikes, append "Dislike(s)" locale
			if (comment.dislikes !== undefined) {
				var dislikeCount = comment.dislikes + ' ' + locale.dislike[(comment.dislikes === 1 ? 0 : 1)];
			}

			// Add dislike count to HTML template
			template['dislike-count'] = '<?php echo $hashover->html->likeCount ('dislikes', 'permalink', '(dislikeCount || \'\')'); ?>';

<?php endif; ?>
			// Add name HTML to template
			template.name = '<?php echo $hashover->html->nameWrapper ('nameLink', 'nameClass'); ?>';

<?php if ($hashover->setup->usesUserTimezone !== false): ?>
			// Local comment post date
			var postDate = new Date (comment['sort-date'] * 1000);

<?php if ($hashover->setup->usesShortDates !== false): ?>
			// Local comment post date to remove time from
			var postDateCopy = new Date (postDate.getTime ());

			// Local date
			var localDate = new Date ();

			// Format local time if the comment was posted today
			if (postDateCopy.setHours (0, 0, 0, 0) === localDate.setHours (0, 0, 0, 0)) {
				commentDate = locale.today.replace ('%s', formatDate (timeFormat, postDate));
			}
<?php else: ?>
			// Format a long local date/time
			commentDate = formatDate (locale.dateTime, postDate);
<?php endif; ?>
<?php endif; ?>

			// Add date from comment as permalink hyperlink to template
			template.date = '<?php echo $hashover->html->dateLink ('permalink', 'commentDate'); ?>';

			// Add "Reply" hyperlink to template
			template['reply-link'] = '<?php echo $hashover->html->formLink ('reply', 'permalink', 'replyClass', 'replyTitle'); ?>';

			// Add reply count to template
			if (comment.replies !== undefined) {
				template['reply-count'] = comment.replies.length;

				if (template['reply-count'] > 0) {
					if (template['reply-count'] !== 1) {
						template['reply-count'] += ' <?php echo $hashover->locale->get ('replies'); ?>';
					} else {
						template['reply-count'] += ' <?php echo $hashover->locale->get ('reply'); ?>';
					}
				}
			}

			// Add HTML anchor tag to URLs
			var body = comment.body.replace (linkRegex, '<a href="$1" rel="noopener noreferrer" target="_blank">$1</a>');

			// Replace [img] tags with external image placeholder if enabled
			body = body.replace (imageRegex, function (fullURL, url) {
<?php if ($hashover->setup->allowsImages !== false): ?>
				// Get image extension from URL
				var urlExtension = url.split ('#')[0];
				    urlExtension = urlExtension.split ('?')[0];
				    urlExtension = urlExtension.split ('.');
				    urlExtension = urlExtension.pop ();

				// Check if the image extension is an allowed type
				if (imageExtensions.indexOf (urlExtension) > -1) {
					// If so, create a wrapper element for the embedded image
					var embeddedImage = createElement ('span', {
						className: 'hashover-embedded-image-wrapper'
					});

					// Append an image tag to the embedded image wrapper
					embeddedImage.appendChild (createElement ('img', {
						className: 'hashover-embedded-image',
						src: imagePlaceholder,
						title: locale.externalImageTip,
						alt: 'External Image',

						dataset: {
							placeholder: imagePlaceholder,
							url: url
						}
					}));

					// And return the embedded image HTML
					return embeddedImage.outerHTML;
				}

<?php endif; ?>
				// Convert image URL into an anchor tag
				return '<a href="' + url + '" rel="noopener noreferrer" target="_blank">' + url + '</a>';
			});

			// Parse markdown in comment
			body = parseMarkdown (body);

			// Check for code tags
			if (codeOpenRegex.test (body) === true) {
				// Replace code tags with marker text
				body = body.replace (codeTagRegex, function (fullTag, openTag, innerHTML, closeTag) {
					var codeMarker = openTag + 'CODE_TAG[' + codeTagCount + ']' + closeTag;

					codeTags[codeTagCount] = EOLTrim (innerHTML);
					codeTagCount++;

					return codeMarker;
				});
			}

			// Check for pre tags
			if (preOpenRegex.test (body) === true) {
				// Replace pre tags with marker text
				body = body.replace (preTagRegex, function (fullTag, openTag, innerHTML, closeTag) {
					var preMarker = openTag + 'PRE_TAG[' + preTagCount + ']' + closeTag;

					preTags[preTagCount] = EOLTrim (innerHTML);
					preTagCount++;

					return preMarker;
				});
			}

			// Check for various multi-line tags
			for (var trimTag in trimTagRegexes) {
				if (trimTagRegexes.hasOwnProperty (trimTag) === true
				    && trimTagRegexes[trimTag]['test'].test (body) === true)
				{
					// Trim whitespace
					body = body.replace (trimTagRegexes[trimTag]['replace'], tagTrimmer);
				}
			}

			// Break comment into paragraphs
			var paragraphs = body.split (paragraphRegex);
			var pdComment = '';

			// Wrap comment in paragraph tag
			// Replace single line breaks with break tags
			for (var i = 0, il = paragraphs.length; i < il; i++) {
				pdComment += '<p>' + paragraphs[i].replace (lineRegex, '<br>') + '</p>' + serverEOL;
			}

			// Replace code tag markers with original code tag HTML
			if (codeTagCount > 0) {
				pdComment = pdComment.replace (codeTagMarkerRegex, function (marker, number) {
					return codeTags[number];
				});
			}

			// Replace pre tag markers with original pre tag HTML
			if (preTagCount > 0) {
				pdComment = pdComment.replace (preTagMarkerRegex, function (marker, number) {
					return preTags[number];
				});
			}

			// Add comment data to template
			template.comment = pdComment;
		} else {
			// Append notice class
			classes += ' hashover-notice ' + comment['notice-class'];

			// Add notice to template
			template.comment = comment.notice;

			// Add name HTML to template
			template.name = '<?php echo $hashover->html->nameWrapper ('comment.title', 'nameClass'); ?>';
		}

		// Comment HTML template
<?php

		echo $hashover->html->asJSVar ($hashover->templater->parseTemplate (), 'html', "\t\t");

?>

		// Recursively parse replies
		if (comment.replies !== undefined) {
			for (var reply = 0, total = comment.replies.length; reply < total; reply++) {
				replies += parseComment (comment.replies[reply], comment, collapse);
			}
		}

		return '<?php echo $hashover->html->commentWrapper ('permalink', 'classes', 'html + replies'); ?>';
	}

	// Generate file from permalink
	function fileFromPermalink (permalink)
	{
		var file = permalink.slice (1);
		    file = file.replace (/r/g, '-');
		    file = file.replace ('-pop', '');

		return file;
	}

	// Change and hyperlink, like "Edit" or "Reply", into a "Cancel" hyperlink
	function cancelSwitcher (form, link, wrapper, permalink)
	{
		// Initial state properties of hyperlink
		var reset = {
			textContent: link.textContent,
			title: link.title,
			onclick: link.onclick
		};

		function linkOnClick ()
		{
			// Remove fields from form wrapper
			// wrapper.textContent = '';

			// Reset button
			link.textContent = reset.textContent;
			link.title = reset.title;
			link.onclick = reset.onclick;

			return false;
		}

		// Change hyperlink to "Cancel" hyperlink
		// link.textContent = locale.cancel;
		// link.title = locale.cancel;

		// This resets the "Cancel" hyperlink to initial state onClick
		// link.onclick = linkOnClick;
<?php if ($hashover->setup->usesCancelButtons !== false): ?>

		// Get "Cancel" button
		var cancelButtonId = 'hashover-' + form + '-cancel-' + permalink;
		var cancelButton = getElement (cancelButtonId, true);

		// Attach event listeners to "Cancel" button
		cancelButton.onclick = function () {
		  var curForm = getElement('hashover-reply-' + permalink, true);
		  wrapper.removeChild(curForm);

		  var commentForm = getElement('hashover-form', true);
		  link.style.display = 'block';
		  commentForm.style.display = 'block';
		};
<?php endif; ?>
	}

	// Returns false if key event is the enter key
	function enterCheck (event)
	{
		return (event.keyCode === 13) ? false : true;
	}

	// Prevents enter key on inputs from submitting form
	function preventSubmit (form)
	{
		// Get login info inputs
		var infoInputs = form.getElementsByClassName ('hashover-input-info');

		// Set enter key press to return false
		for (var i = 0, il = infoInputs.length; i < il; i++) {
			infoInputs[i].onkeypress = enterCheck;
		}
	}

	// Check whether browser has classList support
	if (document.documentElement.classList) {
		// If so, wrap relevant functions
		// classList.contains () method
		var containsClass = function (element, className)
		{
			return element.classList.contains (className);
		};

		// classList.add () method
		var addClass = function (element, className)
		{
			element.classList.add (className);
		};

		// classList.remove () method
		var removeClass = function (element, className)
		{
			element.classList.remove (className);
		};
	} else {
		// If not, define fallback functions
		// classList.contains () method
		var containsClass = function (element, className)
		{
			if (!element || !element.className) {
				return false;
			}

			var regex = new RegExp ('(^|\\s)' + className + '(\\s|$)');
			return regex.test (element.className);
		};

		// classList.add () method
		var addClass = function (element, className)
		{
			if (!element) {
				return false;
			}

			if (!containsClass (element, className)) {
				element.className += (element.className ? ' ' : '') + className;
			}
		};

		// classList.remove () method
		var removeClass = function (element, className)
		{
			if (!element || !element.className) {
				return false;
			}

			var regex = new RegExp ('(^|\\s)' + className + '(\\s|$)', 'g');
			element.className = element.className.replace (regex, '$2');
		};
	}

	// Gets a computed element style by property
	function compatComputedStyle (element, proterty, type)
	{
		var computedStyle;

		// IE, other
		if (window.getComputedStyle === undefined) {
			computedStyle = element.currentStyle[proterty];
		}

		// Mozilla Firefox, Google Chrome
		computedStyle = window.getComputedStyle (element, null);
		computedStyle = computedStyle.getPropertyValue (proterty);

		// Cast value to specified type
		switch (type) {
			case 'int': {
				computedStyle = computedStyle.replace (/px|em/, '');
				computedStyle = parseInt (computedStyle) || 0;
				break;
			}

			case 'float': {
				computedStyle = computedStyle.replace (/px|em/, '');
				computedStyle = parseFloat (computedStyle) || 0.0;
				break;
			}
		}

		return computedStyle;
	}

	// Gets the client height of a message element
	function getMessageHeight (element, setChild)
	{
		setChild = setChild || false;

		var firstChild = element.children[0];
		var maxHeight = 80;

		// If so, set max-height style to initial
		firstChild.style.maxHeight = 'initial';

		// Get various computed styles
		var borderTop = compatComputedStyle (firstChild, 'border-top-width', 'int');
		var borderBottom = compatComputedStyle (firstChild, 'border-bottom-width', 'int');
		var marginBottom = compatComputedStyle (firstChild, 'margin-bottom', 'int');
		var border = borderTop + borderBottom;

		// Calculate its client height
		maxHeight = firstChild.clientHeight + border + marginBottom;

		// Set its max-height style as well if told to
		if (setChild === true) {
			firstChild.style.maxHeight = maxHeight + 'px';
		} else {
			firstChild.style.maxHeight = '';
		}

		return maxHeight;
	}

	// Open a message element
	function openMessage (element)
	{
		// Add classes to indicate message element is open
		removeClass (element, 'hashover-message-animated');
		addClass (element, 'hashover-message-open');

		var maxHeight = getMessageHeight (element);
		var firstChild = element.children[0];

		// Remove class indicating message element is open
		removeClass (element, 'hashover-message-open');

		setTimeout (function () {
			// Add class to indicate message element is open
			addClass (element, 'hashover-message-open');
			addClass (element, 'hashover-message-animated');

			// Set max-height styles
			element.style.maxHeight = maxHeight + 'px';
			firstChild.style.maxHeight = maxHeight + 'px';

			// Set max-height style to initial after transition
			setTimeout (function () {
				element.style.maxHeight = 'initial';
				firstChild.style.maxHeight = 'initial';
			}, 150);
		}, 150);
	}

	// Close a message element
	function closeMessage (element)
	{
		// Set max-height style to specific height before transition
		element.style.maxHeight = getMessageHeight (element, true) + 'px';

		setTimeout (function () {
			// Remove max-height style from message elements
			element.children[0].style.maxHeight = '';
			element.style.maxHeight = '';

			// Remove classes indicating message element is open
			removeClass (element, 'hashover-message-open');
			removeClass (element, 'hashover-message-error');
		}, 150);
	}

	// Handle message element(s)
	function showMessage (messageText, type, permalink, error, isReply, isEdit)
	{
		type = type || 'main';
		permalink = permalink || '';
		error = error || true;
		isReply = isReply || false;
		isEdit = isEdit || false;

		var container;
		var message;

		// Decide which message element to use
		if (isEdit === true) {
			// An edit form message
			container = getElement ('hashover-edit-message-container-' + permalink, true);
			message = getElement ('hashover-edit-message-' + permalink, true);
		} else {
			if (isReply !== true) {
				// The primary comment form message
				container = getElement ('hashover-message-container', true);
				message = getElement ('hashover-message', true);
			} else {
				// Of a reply form message
				container = getElement ('hashover-reply-message-container-' + permalink, true);
				message = getElement ('hashover-reply-message-' + permalink, true);
			}
		}

		if (messageText !== undefined && messageText !== '') {
			// Add message text to element
			message.textContent = messageText;

			// Add class to indicate message is an error if set
			if (error === true) {
				addClass (container, 'hashover-message-error');
			}
		}

		// Add class to indicate message element is open
		openMessage (container);

		// Add the comment to message counts
		if (messageTimeouts[permalink] === undefined) {
			messageTimeouts[permalink] = {};
		}

		// Clear necessary timeout
		if (messageTimeouts[permalink][type] !== undefined) {
			clearTimeout (messageTimeouts[permalink][type]);
		}

		// Add timeout to close message element after 10 seconds
		messageTimeouts[permalink][type] = setTimeout (function () {
			closeMessage (container);
		}, 10000);
	}

	// Handles display of various warnings when user attempts to post or login
	function emailValidator (form, subscribe, type, permalink, isReply, isEdit)
	{
		if (form.email === undefined) {
			return true;
		}

		// Whether the e-mail form is empty
		if (form.email.value === '') {
			// Return true if user unchecked the subscribe checkbox
			if (getElement (subscribe, true).checked === false) {
				return true;
			}

			// If so, warn the user that they won't receive reply notifications
			if (confirm ('<?php echo $hashover->locale->get ('no-email-warning'); ?>') === false) {
				form.email.focus ();
				return false;
			}
		} else {
			var message;
			var emailRegex = /\S+@\S+/;

			// If not, check if the e-mail is valid
			if (emailRegex.test (form.email.value) === false) {
				// Return true if user unchecked the subscribe checkbox
				if (getElement (subscribe, true).checked === false) {
					form.email.value = '';
					return true;
				}

				message = '<?php echo $hashover->locale->get ('invalid-email'); ?>';
				showMessage (message, type, permalink, true, isReply, isEdit);
				form.email.focus ();

				return false;
			}
		}

		return true;
	}

	// Validate a comment form e-mail field
	function validateEmail (type, permalink, form, isReply, isEdit)
	{
		type = type || 'main';
		permalink = permalink || null;
		isReply = isReply || false;
		isEdit = isEdit || false;

		var subscribe;

		// Check whether comment is an edit
		if (isEdit === true) {
			// If it is, validate edit form e-mail
			subscribe = 'hashover-subscribe-' + permalink;
		} else {
			// If it is not, validate as primary or reply
			if (isReply !== true) {
				// Validate primary form e-mail
				subscribe = 'hashover-subscribe';
			} else {
				// Validate reply form e-mail
				subscribe = 'hashover-subscribe-' + permalink;
			}
		}

		// Validate form fields
		return emailValidator (form, subscribe, type, permalink, isReply, isEdit);
	}

	// Validate a comment form
	function commentValidator (form, skipComment, isReply)
	{
		skipComment = skipComment || false;

		// Check each input field for if they are required
		for (var field in fieldOptions) {
			// Skip other people's prototypes
			if (fieldOptions.hasOwnProperty (field) !== true) {
				continue;
			}

			// Check if the field is required, and that the input exists
			if (fieldOptions[field] === 'required' && form[field] !== undefined) {
				// Check if it has a value
				if (form[field].value === '') {
					// If not, add a class indicating a failed post
					addClass (form[field], 'hashover-emphasized-input');

					// Focus the input
					form[field].focus ();

					// Return error message to display to the user
					return locale.fieldNeeded.replace ('%s', locale[field]);
				}

				// Remove class indicating a failed post
				removeClass (form[field], 'hashover-emphasized-input');
			}
		}

		// Check if a comment was given
		if (skipComment !== true && form.comment.value === '') {
			// If not, add a class indicating a failed post
			addClass (form.comment, 'hashover-emphasized-input');

			// Focus the comment textarea
			form.comment.focus ();

			// Error message to display to the user
			if (isReply === true) {
				var errorMessage = '<?php echo $hashover->locale->get ('reply-needed'); ?>';
			} else {
				var errorMessage = '<?php echo $hashover->locale->get ('comment-needed'); ?>';
			}

			// Return a error message to display to the user
			return errorMessage;
		}

		return true;
	}

	// Validate required comment credentials
	function validateComment (skipComment, form, type, permalink, isReply, isEdit)
	{
		skipComment = skipComment || false;
		type = type || 'main';
		permalink = permalink || null;
		isReply = isReply || false;
		isEdit = isEdit || false;

		// Validate comment form
		var message = commentValidator (form, skipComment, isReply);

		// Display the validator's message
		if (message !== true) {
			showMessage (message, type, permalink, true, isReply, isEdit);
			return false;
		}

		// Validate e-mail if user isn't logged in or is editing
		if (userIsLoggedIn === false || isEdit === true) {
			// Return false on any failure
			if (validateEmail (type, permalink, form, isReply, isEdit) === false) {
				return false;
			}
		}

		return true;
	}

	// For posting comments, both traditionally and via AJAX
	function postComment (destination, form, button, callback, type, permalink, close, isReply, isEdit)
	{
		type = type || 'main';
		permalink = permalink || '';
		close = close || null;
		isReply = isReply || false;
		isEdit = isEdit || false;

		// Return false if comment is invalid
		if (validateComment (false, form, type, permalink, isReply, isEdit) === false) {
			return false;
		}

		// Disable button
		setTimeout (function () {
			button.disabled = true;
		}, 500);

<?php if ($hashover->setup->usesAJAX !== false): ?>
		var httpRequest = new XMLHttpRequest ();
		var formElements = form.elements;
		var elementsLength = formElements.length;
		var queries = [];

		// AJAX response handler
		function commentHandler ()
		{
			// Do nothing if request wasn't successful in a meaningful way
			if (this.readyState !== 4 || this.status !== 200) {
				return;
			}

			// Parse AJAX response as JSON
			var json = JSON.parse (this.responseText);
			var scrollToElement;

			// Check if JSON includes a comment
			if (json.comment !== undefined) {
				// If so, execute callback function
				callback (json, permalink, destination, isReply);

				// Execute callback function if one was provided
				// if (close !== null) {
				//   close ();
				// }

				// Scroll comment into view
				scrollToElement = getElement (json.comment.permalink, true);
				scrollToElement.scrollIntoView ({ behavior: 'smooth' });

				// Clear form
				form.comment.value = '';
			} else {
				// If not, display the message return instead
				showMessage (json.message, type, permalink, (json.type === 'error'), isReply, isEdit);
				return false;
			}

			// Re-enable button on success
			setTimeout (function () {
				button.disabled = false;
			}, 1000);
		}

		// Sends a request to post a comment
		function sendRequest ()
		{
			// Handle AJAX request return data
			httpRequest.onreadystatechange = commentHandler;

			// Send post comment request
			httpRequest.open ('POST', form.action, true);
			httpRequest.setRequestHeader ('Content-type', 'application/x-www-form-urlencoded');
			httpRequest.send (queries.join ('&'));
		}

		// Get all form input names and values
		for (var i = 0; i < elementsLength; i++) {
			// Skip login/logout input
			if (formElements[i].name === 'login' || formElements[i].name === 'logout') {
				continue;
			}

			// Skip unchecked checkboxes
			if (formElements[i].type === 'checkbox' && formElements[i].checked !== true) {
				continue;
			}

			// Skip delete input
			if (formElements[i].name === 'delete') {
				continue;
			}

			// Add query to queries array
			queries.push (formElements[i].name + '=' + encodeURIComponent (formElements[i].value));
		}

		// Add AJAX query to queries array
		queries.push ('ajax=yes');

<?php if ($hashover->setup->usesAutoLogin !== false): ?>
		// Check if the user is logged in
		if (userIsLoggedIn !== true || isEdit === true) {
			// If not, send a login request
			var loginRequest = new XMLHttpRequest ();
			var loginQueries = queries.concat (['login=Login']);

			// Handle AJAX request return data
			loginRequest.onreadystatechange = function ()
			{
				// Do nothing if request wasn't successful in a meaningful way
				if (this.readyState !== 4 || this.status !== 200) {
					return;
				}

				// Send post comment request after login
				userIsLoggedIn = true;
				sendRequest ();
			};

			// Send login request
			loginRequest.open ('POST', form.action, true);
			loginRequest.setRequestHeader ('Content-type', 'application/x-www-form-urlencoded');
			loginRequest.send (loginQueries.join ('&'));
		} else {
			// If so, send post comment request normally
			sendRequest ();
		}
<?php else: ?>
		// Send post comment request
		sendRequest ();
<?php endif; ?>

		// Re-enable button after 20 seconds
		setTimeout (function () {
			// Abort unfinish request
			httpRequest.abort ();

			// Re-enable button
			button.disabled = false;
		}, 20000);

		return false;
<?php else: ?>
		// Re-enable button after 20 seconds
		setTimeout (function () {
			button.disabled = false;
		}, 20000);

		return true;
<?php endif; ?>
	}

<?php if ($hashover->setup->usesAJAX !== false): ?>
	// Converts an HTML string to DOM NodeList
	function HTMLToNodeList (html)
	{
		return createElement ('div', { innerHTML: html }).childNodes;
	}

	// Increase comment counts
	function incrementCounts (isReply)
	{
		// Count top level comments
		if (isReply === false) {
			primaryCount++;
		}

		// Increase all count
		totalCount++;
	}

	// For adding new comments to comments array
	function addComments (comment, isReply, index)
	{
		isReply = isReply || false;
		index = index || null;

		// Check that comment is not a reply
		if (isReply !== true) {
			// If so, add to primary comments
			if (index !== null) {
				PHPContent.comments.splice (index, 0, comment);
				return;
			}

			PHPContent.comments.push (comment);
			return;
		}

		// If not, fetch parent comment
		var parentPermalink = getParentPermalink (comment.permalink);
		var parent = findByPermalink (parentPermalink, PHPContent.comments);

		// Check if the parent comment exists
		if (parent !== null) {
			// If so, check if comment has replies
			if (parent.replies !== undefined) {
				// If so, add comment to reply array
				if (index !== null) {
					parent.replies.splice (index, 0, comment);
					return;
				}

				parent.replies.push (comment);
				return;
			}

			// If not, create reply array
			parent.replies = [comment];
		}

		// Otherwise, add to primary comments
		PHPContent.comments.push (comment);
	}

	// For posting comments
	AJAXPost = function (json, permalink, destination, isReply)
	{
		// If there aren't any comments, replace first comment message
		if (totalCount === 0) {
			PHPContent.comments[0] = json.comment;
			destination.innerHTML = parseComment (json.comment);
		} else {
			// Add comment to comments array
			addComments (json.comment, isReply);

			// Create div element for comment
			var commentNode = HTMLToNodeList (parseComment (json.comment));

			// Append comment to parent element
			if (streamMode === true && permalink.split('r').length > streamDepth) {
				destination.parentNode.insertBefore (commentNode[0], destination.nextSibling);
			} else {
				destination.appendChild (commentNode[0]);
			}
		}

		// Add controls to the new comment
		addControls (json.comment);

		// Update comment count
		getElement ('hashover-count').textContent = json.count;
		incrementCounts (isReply);
	};

	// For editing comments
	AJAXEdit = function (json, permalink, destination, isReply)
	{
		// Get old comment element nodes
		var comment = getElement (permalink, true);
		var oldNodes = comment.childNodes;
		var oldComment = findByPermalink (permalink, PHPContent.comments);

		// Get new comment element nodes
		var newNodes = HTMLToNodeList (parseComment (json.comment));
		    newNodes = newNodes[0].childNodes;

		// Replace old comment with edited comment
		for (var i = 0, il = newNodes.length; i < il; i++) {
			if (typeof (oldNodes[i]) === 'object'
			    && typeof (newNodes[i]) === 'object')
			{
				comment.replaceChild (newNodes[i], oldNodes[i]);
			}
		}

		// Add controls back to the comment
		addControls (json.comment);

		// Update old in array comment with edited comment
		for (var attribute in json.comment) {
			oldComment[attribute] = json.comment[attribute];
		}
	};

<?php endif; ?>
	// Attach click event to accepted HTML revealer hyperlinks
	function acceptedHTMLOnclick (type, permalink)
	{
		permalink = (permalink !== undefined) ? '-' + permalink : '';

		// Get accepted HTML message elements
		var acceptedHTMLID = 'hashover-' + type + '-formatting';
		var acceptedHTML = getElement (acceptedHTMLID + permalink, true);
		var acceptedHTMLMessage = getElement (acceptedHTMLID + '-message' + permalink, true);

		// Attach click event to accepted HTML revealer hyperlink
		acceptedHTML.onclick = function ()
		{
			if (containsClass (acceptedHTMLMessage, 'hashover-message-open')) {
				closeMessage (acceptedHTMLMessage);
				return false;
			}

			openMessage (acceptedHTMLMessage);
			return false;
		}
	}

	// Displays reply form
	function hashoverReply (permalink)
	{
		// Get reply link element
		var link = getElement ('hashover-reply-link-' + permalink, true);

		// Get file
		var file = fileFromPermalink (permalink);

		// Create reply form element
		var form = createElement ('form', {
			id: 'hashover-reply-' + permalink,
			className: 'hashover-reply-form',
			method: 'post',
			action: httpScripts + '/postcomments.php'
		});

<?php

		echo $hashover->html->asJSVar ($hashover->html->replyForm ('permalink', 'file'), 'formHTML', "\t\t");

?>

		// Place reply fields into form
		form.innerHTML = formHTML;

		// Prevent input submission
		preventSubmit (form);

		// Add form to page
		// var replyForm = getElement ('hashover-placeholder-reply-form-' + permalink, true);
		var replyForm = getElement('hashover-form-section', true);

		var commentForm = getElement('hashover-form', true);
		if (commentForm) {
		  commentForm.style.display = 'none';
		}

		replyForm.appendChild (form);

		// Change "Reply" link to "Cancel" link
	  cancelSwitcher ('reply', link, replyForm, permalink);
		link.style.display = 'none';

		// Attach event listeners to "Post Reply" button
		var postReply = getElement ('hashover-reply-post-' + permalink, true);

		// Get the element of comment being replied to
		// var destination = getElement (permalink, true);
    var destination = getElement ('hashover-sort-div', true);

		// Attach click event to accepted HTML revealer hyperlink
		// acceptedHTMLOnclick ('reply', permalink);

		// Onclick
		postReply.onclick = function ()
		{
			return postComment (destination, form, this, AJAXPost, 'reply', permalink, link.onclick, true, false);
		};

		// Onsubmit
		postReply.onsubmit = function ()
		{
			return postComment (destination, form, this, AJAXPost, 'reply', permalink, link.onclick, true, false);
		};

		// Focus comment field
		form.comment.focus ();

		return true;
	}

	// Displays edit form
	function hashoverEdit (comment)
	{
		if (comment['user-owned'] !== true) {
			return false;
		}

		// Get permalink from comment JSON object
		var permalink = comment.permalink;

		// Get edit link element
		var link = getElement ('hashover-edit-link-' + permalink, true);

		// Get file
		var file = fileFromPermalink (permalink);

		// Get name and website
		var name = comment.name || '';
		var website = comment.website || '';

		// Get and clean comment body
		var body = comment.body.replace (linkRegex, '$1');

		// Create edit form element
		var form = createElement ('form', {
			id: 'hashover-edit-' + permalink,
			className: 'hashover-edit-form',
			method: 'post',
			action: httpScripts + '/postcomments.php'
		});

<?php

		echo $hashover->html->asJSVar ($hashover->html->editForm ('permalink', 'file', 'name', 'website', 'body'), 'formHTML', "\t\t");

?>

		// Place edit form fields into form
		form.innerHTML = formHTML;

		// Prevent input submission
		preventSubmit (form);

		// Add edit form to page
		var editForm = getElement ('hashover-placeholder-edit-form-' + permalink, true);
		    editForm.appendChild (form);

		// Set status dropdown menu option to comment status
		ifElement ('hashover-edit-status-' + permalink, function (status) {
			if (comment.status !== undefined) {
				status.selectedIndex = commentStatuses.indexOf (comment.status);
			}
		});

		// Blank out password field
		setTimeout (function () {
			if (form.password !== undefined) {
				form.password.value = '';
			}
		}, 100);

		// Uncheck subscribe checkbox if user isn't subscribed
		if (comment.subscribed !== true) {
			getElement ('hashover-subscribe-' + permalink, true).checked = null;
		}

		// Displays onClick confirmation dialog for comment deletion
		getElement ('hashover-edit-delete-' + permalink, true).onclick = function ()
		{
			return confirm ('<?php echo $hashover->locale->get ('delete-comment'); ?>');
		};

		// Change "Edit" link to "Cancel" link
		cancelSwitcher ('edit', link, editForm, permalink);

		// Attach event listeners to "Save Edit" button
		var saveEdit = getElement ('hashover-edit-post-' + permalink, true);

		// Get the element of comment being replied to
		var destination = getElement (permalink, true);

		// Attach click event to accepted HTML revealer hyperlink
		// acceptedHTMLOnclick ('edit', permalink);

		// Onclick
		saveEdit.onclick = function ()
		{
			return postComment (destination, form, this, AJAXEdit, 'edit', permalink, link.onclick, false, true);
		};

		// Onsubmit
		saveEdit.onsubmit = function ()
		{
			return postComment (destination, form, this, AJAXEdit, 'edit', permalink, link.onclick, false, true);
		};

		return false;
	}
<?php if ($hashover->setup->collapsesComments !== false): ?>

	// For showing more comments, via AJAX or removing a class
	function hideMoreLink (finishedCallback)
	{
		finishedCallback = finishedCallback || null;

		// Add class to hide the more hyperlink
		addClass (moreLink, 'hashover-hide-more-link');

		setTimeout (function () {
			// Remove the more hyperlink from page
			if (sortDiv.contains (moreLink) === true) {
				sortDiv.removeChild (moreLink);
			}

			// Show comment count and sort options
			getElement ('hashover-count-wrapper').style.display = '';

			// Show popular comments section
			ifElement ('hashover-popular-section', function (popularSection) {
				popularSection.style.display = '';
			});

			// Get each hidden comment element
			var collapsed = sortDiv.getElementsByClassName ('hashover-hidden');

			// Remove hidden comment class from each comment
			for (var i = collapsed.length - 1; i >= 0; i--) {
				removeClass (collapsed[i], 'hashover-hidden');
			}

			// Execute callback function
			if (finishedCallback !== null) {
				finishedCallback ();
			}
		}, 350);
	}
<?php if ($hashover->setup->usesAJAX !== false): ?>

	// For appending new comments to the thread on page
	function appendComments (comments)
	{
		var comment;
		var isReply;
		var element;
		var parent;

		for (var i = 0, il = comments.length; i < il; i++) {
			// Skip existing comments
			if (findByPermalink (comments[i].permalink, PHPContent.comments) !== null) {
				// Check comment's replies
				if (comments[i].replies !== undefined) {
					appendComments (comments[i].replies);
				}

				continue;
			}

			// Check if comment is a reply
			isReply = (comments[i].permalink.indexOf ('r') > -1);

			// Add comment to comments array
			addComments (comments[i], isReply, i);

			// Parse comment, convert HTML to DOM node
			comment = HTMLToNodeList (parseComment (comments[i], null, true));

			// Check that comment is not a reply
			if (isReply !== true) {
				// If so, append to primary comments
				element = moreDiv;
			} else {
				// If not, append to its parent's element
				parent = getParentPermalink (comments[i].permalink, true);
				element = getElement (parent, true) || moreDiv;
			}

			// Otherwise append it to the primary element
			element.appendChild (comment[0]);

			// Add controls to the comment
			addControls (comments[i]);
		}
	}
<?php endif; ?>

	// onClick event for more button
	function showMoreComments (element, finishedCallback)
	{
		finishedCallback = finishedCallback || null;

		// Do nothing if already showing all comments
		if (showingMore === true) {
			// Execute callback function
			if (finishedCallback !== null) {
				finishedCallback ();
			}

			return false;
		}

<?php if ($hashover->setup->usesAJAX !== false): ?>
		var httpRequest = new XMLHttpRequest ();
		var queries = ['url=' + encodeURIComponent (pageURL), 'start=' + collapseLimit, 'ajax=yes'];

		// Handle AJAX request return data
		httpRequest.onreadystatechange = function ()
		{
			// Do nothing if request wasn't successful in a meaningful way
			if (this.readyState !== 4 || this.status !== 200) {
				return;
			}

			// Parse AJAX response as JSON
			var json = JSON.parse (this.responseText);

			// Display the comments
			appendComments (json.comments);

			// Remove loading class from element
			removeClass (element, 'hashover-loading');

			// Hide the more hyperlink and display the comments
			hideMoreLink (finishedCallback);
		};

		// Open and send request
		httpRequest.open ('POST', httpRoot + '/api/json.php', true);
		httpRequest.setRequestHeader ('Content-type', 'application/x-www-form-urlencoded');
		httpRequest.send (queries.join ('&'));

		// Set class to indicate loading to element
		addClass (element, 'hashover-loading');
<?php else: ?>
		// Hide the more hyperlink and display the comments
		hideMoreLink (finishedCallback);
<?php endif; ?>

		// Set all comments as shown
		showingMore = true;

		return false;
	}
<?php endif; ?>

	// Callback to close the embedded image
	function closeEmbeddedImage (image) {
		// Reset source
		image.src = image.dataset.placeholder;

		// Reset title
		image.title = locale.externalImageTip;

		// Remove loading class from wrapper
		removeClass (image.parentNode, 'hashover-loading');
	}

	// Onclick callback function for embedded images
	function embeddedImageCallback ()
	{
		// If embedded image is open, close it and return false
		if (this.src === this.dataset.url) {
			closeEmbeddedImage (this);
			return false;
		}

		// Set title
		this.title = '<?php echo $hashover->locale->get ('loading'); ?>';

		// Add loading class to wrapper
		addClass (this.parentNode, 'hashover-loading');

		// Change title and remove load event handler once image is loaded
		this.onload = function ()
		{
			this.title = '<?php echo $hashover->locale->get ('click-to-close'); ?>';
			this.onload = null;

			// Remove loading class from wrapper
			removeClass (this.parentNode, 'hashover-loading');
		};

		// Close embedded image if any error occurs
		this.onerror = function ()
		{
			closeEmbeddedImage (this);
		};

		// Set placeholder image to embedded source
		this.src = this.dataset.url;
	}

	// Changes Element.textContent onmouseover and reverts onmouseout
	function mouseOverChanger (element, over, out)
	{
		if (over === null || out === null) {
			element.onmouseover = null;
			element.onmouseout = null;

			return false;
		}

		element.onmouseover = function ()
		{
			this.textContent = over;
		};

		element.onmouseout = function ()
		{
			this.textContent = out;
		};
	}
<?php if ($likesOrDislikes !== false): ?>

	// For liking comments
	function likeComment (action, permalink)
	{
		// Get file
		var file = fileFromPermalink (permalink);

		var actionLink = getElement ('hashover-' + action + '-' + permalink, true);
		var likesElement = getElement ('hashover-' + action + 's-' + permalink, true);
		var dislikesClass = (action === 'like') ? '<?php if ($allowsDislikes === true) echo ' hashover-dislikes-enabled'; ?>' : '';

		// Load "like.php"
		var like = new XMLHttpRequest ();
		var queries;

		// When loaded update like count
		like.onreadystatechange = function ()
		{
			var likeResponse;
			var likesKey, likes = 0;

			// Do nothing if request wasn't successful in a meaningful way
			if (this.readyState !== 4 || this.status !== 200) {
				return;
			}

			// Get JSON response
			likeResponse = JSON.parse (this.responseText);

			// If a message is returned display it to the user
			if (likeResponse.message !== undefined) {
				alert (likeResponse.message);
				return;
			}

			// If an error is returned display a stand error to the user
			if (likeResponse.error !== undefined) {
				alert ('Error! Something went wrong!');
				return;
			}

			// Get number of likes
			likesKey = (action !== 'dislikes') ? 'likes' : 'dislikes';
			likes = likeResponse[likesKey] || 0;

			// Change "Like" button title and class
			if (actionLink.className === 'hashover-' + action + dislikesClass) {
				// Change class to indicate the comment has been liked/disliked
				actionLink.className = 'hashover-' + action + 'd' + dislikesClass;
				actionLink.title = (action === 'like') ? locale.likedComment : locale.dislikedComment;
				actionLink.textContent = (action === 'like') ? locale.liked : locale.disliked;

				// Add listener to change link text to "Unlike" on mouse over
				if (action === 'like') {
					mouseOverChanger (actionLink, locale.unlike, locale.liked);
				}
			} else {
				// Change class to indicate the comment is unliked
				actionLink.className = 'hashover-' + action + dislikesClass;
				actionLink.title = (action === 'like') ? locale.likeComment : locale.dislikeComment;
				actionLink.textContent = (action === 'like') ? locale.like[0] : locale.dislike[0];

				// Add listener to change link text to "Unlike" on mouse over
				if (action === 'like') {
					mouseOverChanger (actionLink, null, null);
				}
			}

			if (likes > 0) {
				// Locale plural key
				var plural = (likes !== 1) ? 1 : 0;

				if (action === 'like') {
					var likeCount = likes + ' ' + locale.like[plural];
				} else {
					var likeCount = likes + ' ' + locale.dislike[plural];
				}

				// Change number of likes; set font weight bold
				likesElement.textContent = likeCount;
				likesElement.style.fontWeight = 'bold';
			} else {
				// Remove like count; set font weight normal
				likesElement.textContent = '';
				likesElement.style.fontWeight = '';
			}
		};

		// Set request queries
		queries  = 'url=' + encodeURIComponent (pageURL);
		queries += '&thread=<?php echo $hashover->misc->jsEscape ($hashover->setup->threadDirectory); ?>';
		queries += '&comment=' + file;
		queries += '&action=' + action;

		// Send request
		like.open ('POST', httpScripts + '/like.php', true);
		like.setRequestHeader ('Content-type', 'application/x-www-form-urlencoded');
		like.send (queries);
	}
<?php endif; ?>

	// Add various events to various elements in each comment
	function addControls (json, popular)
	{
		function stepIntoReplies ()
		{
			if (json.replies !== undefined) {
				for (var reply = 0, total = json.replies.length; reply < total; reply++) {
					addControls (json.replies[reply]);
				}
			}
		}

		if (json.notice !== undefined) {
			stepIntoReplies ();
			return false;
		}

		// Get permalink from JSON object
		var permalink = json.permalink;

		// Get embedded image elements
		var embeddedImgs = document.getElementsByClassName ('hashover-embedded-image');

		// Set onclick functions for external images
		for (var i = 0, il = embeddedImgs.length; i < il; i++) {
			embeddedImgs[i].onclick = embeddedImageCallback;
		}

<?php if ($hashover->setup->collapsesComments !== false): ?>
		// Get thread link of comment
		ifElement ('hashover-thread-link-' + permalink, function (threadLink) {
			// Add onClick event to thread hyperlink
			threadLink.onclick = function ()
			{
				showMoreComments (threadLink, function () {
					var parentThread = permalink.replace (threadRegex, '$1');
					var scrollToElement = getElement (parentThread, true);

					// Scroll to the comment
					scrollToElement.scrollIntoView ({ behavior: 'smooth' });
				});

				return false;
			};
		});

<?php endif; ?>
		// Get reply link of comment
		ifElement ('hashover-reply-link-' + permalink, function (replyLink) {
			// Add onClick event to "Reply" hyperlink
			replyLink.onclick = function ()
			{
				hashoverReply (permalink);
				// Get reply link element
		    var link = getElement ('hashover-reply-link-' + permalink, true);

				return false;
			};
		});

		// Check if logged in user owns the comment
		if (json['user-owned'] === true) {
			ifElement ('hashover-edit-link-' + permalink, function (editLink) {
				// Add onClick event to "Edit" hyperlinks
				editLink.onclick = function ()
				{
					hashoverEdit (json);
					return false;
				};
			});
<?php if ($likesOrDislikes): ?>
		} else {
<?php if ($allowsLikes !== false): ?>
			ifElement ('hashover-like-' + permalink, function (likeLink) {
				// Add onClick event to "Like" hyperlinks
				likeLink.onclick = function ()
				{
					likeComment ('like', permalink);
					return false;
				};

				if (containsClass (likeLink, 'hashover-liked') === true) {
					mouseOverChanger (likeLink, locale.unlike, locale.liked);
				}
			});
<?php endif; ?>
<?php if ($allowsDislikes === true): ?>

			ifElement ('hashover-dislike-' + permalink, function (dislikeLink) {
				// Add onClick event to "Dislike" hyperlinks
				dislikeLink.onclick = function ()
				{
					likeComment ('dislike', permalink);
					return false;
				};
			});
<?php endif; ?>
<?php endif; ?>
		}

		// Recursively execute this function on replies
		stepIntoReplies ();
	}

	// Returns a clone of an object
	function cloneObject (object)
	{
		return JSON.parse (JSON.stringify (object));
	}

	// "Flatten" the comments object
	function getAllComments (comments)
	{
		var commentsCopy = cloneObject (comments);
		var output = [];

		function descend (comment)
		{
			output.push (comment);

			if (comment.replies !== undefined) {
				for (var reply = 0, total = comment.replies.length; reply < total; reply++) {
					descend (comment.replies[reply]);
				}

				delete comment.replies;
			}
		}

		for (var comment = 0, total = commentsCopy.length; comment < total; comment++) {
			descend (commentsCopy[comment]);
		}

		return output;
	}

	// Run all comments in array data through parseComment function
	function parseAll (comments, element, collapse, popular, sort, method)
	{
	 comments = getAllComments (PHPContent.comments).sort (function (a, b) {
		 if (a['sort-date'] === b['sort-date']) {
			return 1;
		 }

		 return a['sort-date'] - b['sort-date'];
		});
		// comments = getAllComments(PHPContent.comments);
		popular = popular || false;
		// sort = sort || false;
	  sort = true;
		// method = method || 'ascending';
		method = 'by-date' || 'descending';

		var commentHTML = '';

		// Parse every comment
		for (var comment = 0, total = comments.length; comment < total; comment++) {
			commentHTML += parseComment (comments[comment], null, collapse, sort, method, popular);
		}

		// Add comments to element's innerHTML
		if ('insertAdjacentHTML' in element) {
			element.insertAdjacentHTML ('beforeend', commentHTML);
		} else {
			element.innerHTML = commentHTML;
		}

		// Add control events
		for (var comment = 0, total = comments.length; comment < total; comment++) {
			addControls (comments[comment]);
		}
	}

	// Comment sorting
	function sortComments (method)
	{
		var tmpArray;
		var sortArray;

		function replyPropertySum (comment, callback)
		{
			var sum = 0;

			if (comment.replies !== undefined) {
				for (var i = 0, il = comment.replies.length; i < il; i++) {
					sum += replyPropertySum (comment.replies[i], callback);
				}
			}

			sum += callback (comment);

			return sum;
		}

		function replyCounter (comment)
		{
			return (comment.replies) ? comment.replies.length : 0;
		}

		function netLikes (comment)
		{
			var likes = comment.likes || 0;
			var dislikes = comment.dislikes || 0;

			return likes - dislikes;
		}

		// Sort methods
		switch (method) {
			case 'descending': {
				tmpArray = getAllComments (PHPContent.comments);
				sortArray = tmpArray.reverse ();
				break;
			}

			case 'by-date': {
				sortArray = getAllComments (PHPContent.comments).sort (function (a, b) {
					if (a['sort-date'] === b['sort-date']) {
						return 1;
					}

					return b['sort-date'] - a['sort-date'];
				});

				break;
			}

			case 'by-likes': {
				sortArray = getAllComments (PHPContent.comments).sort (function (a, b) {
					a.likes = a.likes || 0;
					b.likes = b.likes || 0;
					a.dislikes = a.dislikes || 0;
					b.dislikes = b.dislikes || 0;

					return (b.likes - b.dislikes) - (a.likes - a.dislikes);
				});

				break;
			}

			case 'by-replies': {
				tmpArray = cloneObject (PHPContent.comments);

				sortArray = tmpArray.sort (function (a, b) {
					var ac = (!!a.replies) ? a.replies.length : 0;
					var bc = (!!b.replies) ? b.replies.length : 0;

					return bc - ac;
				});

				break;
			}

			case 'by-discussion': {
				tmpArray = cloneObject (PHPContent.comments);

				sortArray = tmpArray.sort (function (a, b) {
					var replyCountA = replyPropertySum (a, replyCounter);
					var replyCountB = replyPropertySum (b, replyCounter);

					return replyCountB - replyCountA;
				});

				break;
			}

			case 'by-popularity': {
				tmpArray = cloneObject (PHPContent.comments);

				sortArray = tmpArray.sort (function (a, b) {
					var likeCountA = replyPropertySum (a, netLikes);
					var likeCountB = replyPropertySum (b, netLikes);

					return likeCountB - likeCountA;
				});

				break;
			}

			case 'by-name': {
				tmpArray = getAllComments (PHPContent.comments);

				sortArray = tmpArray.sort (function (a, b) {
					var nameA = (a.name || defaultName).toLowerCase ();
					var nameB = (b.name || defaultName).toLowerCase ();

					nameA = (nameA.charAt (0) === '@') ? nameA.slice (1) : nameA;
					nameB = (nameB.charAt (0) === '@') ? nameB.slice (1) : nameB;

					if (nameA > nameB) {
						return 1;
					}

					if (nameA < nameB) {
						return -1;
					}

					return 0;
				});

				break;
			}

			case 'threaded-descending': {
				tmpArray = cloneObject (PHPContent.comments);
				sortArray = tmpArray.reverse ();
				break;
			}

			case 'threaded-by-date': {
				tmpArray = cloneObject (PHPContent.comments);

				sortArray = tmpArray.sort (function (a, b) {
					if (a['sort-date'] === b['sort-date']) {
						return 1;
					}

					return b['sort-date'] - a['sort-date'];
				});

				break;
			}

			case 'threaded-by-likes': {
				tmpArray = cloneObject (PHPContent.comments);

				sortArray = tmpArray.sort (function (a, b) {
					a.likes = a.likes || 0;
					b.likes = b.likes || 0;
					a.dislikes = a.dislikes || 0;
					b.dislikes = b.dislikes || 0;

					return (b.likes - b.dislikes) - (a.likes - a.dislikes);
				});

				break;
			}

			case 'threaded-by-name': {
				tmpArray = cloneObject (PHPContent.comments);

				sortArray = tmpArray.sort (function (a, b) {
					var nameA = (a.name || defaultName).toLowerCase ();
					var nameB = (b.name || defaultName).toLowerCase ();

					nameA = (nameA.charAt (0) === '@') ? nameA.slice (1) : nameA;
					nameB = (nameB.charAt (0) === '@') ? nameB.slice (1) : nameB;

					if (nameA > nameB) {
						return 1;
					}

					if (nameA < nameB) {
						return -1;
					}

					return 0;
				});

				break;
			}

			default: {
				sortArray = PHPContent.comments;
				break;
			}
		}

		parseAll (sortArray, sortDiv, false, false, true, method);
	}

<?php if ($hashover->setup->appendsCSS !== false): ?>
	// Check if comment theme stylesheet is already in page head
	if (typeof (document.querySelector) === 'function') {
		appendCSS = !document.querySelector ('link[href="' + themeCSS + '"]');
	} else {
		// Fallback for old web browsers without querySelector
		var links = head.getElementsByTagName ('link');

		for (var i = 0, il = links.length; i < il; i++) {
			if (links[i].getAttribute ('href') === themeCSS) {
				appendCSS = false;
				break;
			}
		}
	}

	// Create link element for comment stylesheet
	if (appendCSS === true) {
		var css = createElement ('link', {
			rel: 'stylesheet',
			href: themeCSS,
			type: 'text/css',
		});

		// Append comment stylesheet link element to page head
		head.appendChild (css);
	}

<?php endif; ?>
	// Put number of comments into "hashover-comment-count" identified HTML element
	if (totalCount !== 0) {
		ifElement ('hashover-comment-count', function (countElement) {
			countElement.textContent = totalCount;
		});
<?php if ($hashover->setup->APIStatus ('rss') !== 'disabled'): ?>

		// Create link element for comment RSS feed
		var rss = createElement ('link', {
			rel: 'alternate',
			href: httpRoot + '/api/rss.php?url=' + encodeURIComponent (URLHref),
			type: 'application/rss+xml',
			title: 'Comments'
		});

		// Append comment RSS feed link element to page head
		head.appendChild (rss);
<?php endif; ?>
	}

	// Initial HTML
<?php

	$initialHTML = $hashover->html->initialHTML ($hashover->popularList, false);
	echo $hashover->html->asJSVar ($initialHTML, 'initialHTML');

?>

	// Create div tag for HashOver comments to appear in
	if (HashOverDiv === null) {
		HashOverDiv = createElement ('div', { id: 'hashover' });

		// Place HashOver element on page
		if (hashoverScript !== false) {
			var thisScript = getElement ('hashover-script-' + hashoverScript);
			    thisScript.parentNode.insertBefore (HashOverDiv, thisScript);
		} else {
			document.body.appendChild (HashOverDiv);
		}
	}

	// Add class for differentiating desktop and mobile styling
	HashOverDiv.className = 'hashover-' + deviceType;

	// Add class to indicate user login status
	if (userIsLoggedIn === true) {
		addClass (HashOverDiv, 'hashover-logged-in');
	} else {
		addClass (HashOverDiv, 'hashover-logged-out');
	}

	// Add initial HTML to page
	if ('insertAdjacentHTML' in HashOverDiv) {
		HashOverDiv.insertAdjacentHTML ('beforeend', initialHTML);
	} else {
		HashOverDiv.innerHTML = initialHTML;
	}

	// Content passed from PHP
	var PHPContent = HASHOVER_PHP_CONTENT;

	// Get sort div element
	sortDiv = getElement ('hashover-sort-div');

	// Get primary form element
	HashOverForm = getElement ('hashover-form');

	// Display most popular comments
	ifElement ('hashover-top-comments', function (topComments) {
		if (PHPContent.popularComments[0] !== undefined) {
			parseAll (PHPContent.popularComments, topComments, false, true);
		}
	});

	// Add initial event handlers
	parseAll (PHPContent.comments, sortDiv, collapseComments);

<?php if ($hashover->setup->collapsesUI !== false): ?>
	// Decide button text
	var uncollapseText = (totalCount >= 1) ? '<?php echo $show_number_comments; ?>' : locale.postCommentOn;

	// Create hyperlink to uncollapse the comment UI
	var uncollapseUILink = createElement ('a', {
		href: '#',
		className: 'hashover-more-link',
		title: uncollapseText,
		textContent: uncollapseText,

		onclick: function () {
			// Add class to hide the uncollapse UI hyperlink
			addClass (this, 'hashover-hide-more-link');

			setTimeout (function () {
				// Remove the uncollapse UI hyperlink from page
				if (HashOverDiv.contains (uncollapseUILink) === true) {
					HashOverDiv.removeChild (uncollapseUILink);
				}

				// Element to unhide
				var uncollapseIDs = [
					'hashover-form-section',
					'hashover-comments-section',
					'hashover-end-links'
				];

				// Show hidden form elements
				for (var i = 0, il = uncollapseIDs.length; i < il; i++) {
					ifElement (uncollapseIDs[i], function (element) {
						element.style.display = '';
					});
				}

				// Show popular comments section
				if (collapseLimit > 0) {
					ifElement ('hashover-popular-section', function (popularSection) {
						popularSection.style.display = '';
					});
				}
			}, 350);

			return false;
		}
	});

	// Add uncollapse hyperlink to HashOver div
	HashOverDiv.appendChild (uncollapseUILink);

<?php endif; ?>
<?php if ($hashover->setup->collapsesComments !== false): ?>
	// More button text
	var moreLinkText = '<?php echo $more_link_text; ?>';

	// Check whether there are more than the collapse limit
	if (totalCount > collapseLimit) {
		// Create element for the comments
		moreDiv = createElement ('div', {
			className: 'hashover-more-section'
		});

		// If so, create "More Comments" hyperlink
		moreLink = createElement ('a', {
			href: '#',
			className: 'hashover-more-link',
			title: moreLinkText,
			textContent: moreLinkText,

			onclick: function () {
				return showMoreComments (this);
			}
		});

		// Add more button link to sort div
		sortDiv.appendChild (moreDiv);

		// Add more button link to sort div
		sortDiv.appendChild (moreLink);
	} else {
		// If not, consider all comments shown
		showingMore = true;
	}

<?php endif; ?>
	// Attach click event to accepted HTML revealer hyperlink
	// acceptedHTMLOnclick ('main');

	// Attach event listeners to "Post Comment" button
	var postButton = getElement ('hashover-post-button');

	// Onclick
	postButton.onclick = function ()
	{
		return postComment (sortDiv, HashOverForm, postButton, AJAXPost);
	};

	// Onsubmit
	postButton.onsubmit = function ()
	{
		return postComment (sortDiv, HashOverForm, postButton, AJAXPost);
	};

<?php if ($hashover->setup->allowsLogin !== false): ?>
	// Attach event listeners to "Login" button
	if (userIsLoggedIn !== true) {
		var loginButton = getElement ('hashover-login-button');

		// Onclick
		loginButton.onclick = function ()
		{
			return validateComment (true, HashOverForm);
		};

		// Onsubmit
		loginButton.onsubmit = function ()
		{
			return validateComment (true, HashOverForm);
		};
	}

<?php endif; ?>
	// Five method sort
	ifElement ('hashover-sort-select', function (sortSelect) {
		sortSelect.onchange = function ()
		{
<?php if ($hashover->setup->collapsesComments !== false): ?>
			var sortSelectDiv = getElement ('hashover-sort');

			showMoreComments (sortSelectDiv, function () {
				sortDiv.textContent = '';
				sortComments (sortSelect.value);
			});
<?php else: ?>
			sortDiv.textContent = '';
			sortComments (sortSelect.value);
<?php endif; ?>
		};
	});

	// Display reply or edit form when the proper URL queries are set
	if (URLHref.match (/hashover-(reply|edit)=/)) {
		var permalink = URLHref.replace (/.*?hashover-(edit|reply)=(c[0-9r\-pop]+).*?/, '$2');

		if (!URLHref.match ('hashover-edit=')) {
<?php if ($hashover->setup->collapsesComments !== false): ?>
			// Show more comments
			showMoreComments (moreLink, function () {
				// Then display reply form
				hashoverReply (permalink);
			});
<?php else: ?>
			// Display reply form
			hashoverReply (permalink);
<?php endif; ?>
		} else {
			var isPop = permalink.match ('-pop');
			var comments = (isPop) ? PHPContent.popularComments : PHPContent.comments;
<?php if ($hashover->setup->collapsesComments !== false): ?>

			// Show more comments
			showMoreComments (moreLink, function () {
				// Then display edit form
				hashoverEdit (findByPermalink (permalink, comments));
			});
<?php else: ?>
			// Display edit form
			hashoverEdit (findByPermalink (permalink, comments));
<?php endif; ?>
		}
	}

	// Log execution time in JavaScript console
	if (window.console) {
		console.log ('HashOver executed in ' + (Date.now () - execStart) + ' ms.');
	}

	// Callback for scrolling a comment into view on page load
	var scroller = function ()
	{
		setTimeout (function () {
			// Workaround for stupid Chrome bug
			if (URLHash.match (/comments|hashover/)) {
				ifElement (URLHash, function (comments) {
					comments.scrollIntoView ({ behavior: 'smooth' });
				});
			}

			// Jump to linked comment
			if (URLHash.match (/c[0-9]+r*/)) {
<?php if ($hashover->setup->collapsesComments !== false): ?>
				var existingComment = getElement (URLHash);

				// Check if comment exists on the page and is visable
				if (existingComment !== null
				    && containsClass (existingComment, 'hashover-hidden') === false)
				{
					// If so, scroll the comment into view
					existingComment.scrollIntoView ({ behavior: 'smooth' });
				} else {
					// If not, show more comments
					showMoreComments (moreLink, function () {
						ifElement (URLHash, function (comment) {
							comment.scrollIntoView ({ behavior: 'smooth' });
						});
					});
				}
<?php else: ?>
				ifElement (URLHash, function (comment) {
					comment.scrollIntoView ({ behavior: 'smooth' });
				});
<?php endif; ?>
			}
		}, 500);
	};

	// Page onload compatibility wrapper
	if (window.addEventListener) {
		// Rest of the world
		window.addEventListener ('load', scroller, false);
	} else {
		// IE ~8
		window.attachEvent ('onload', scroller);
	}

	// Open the message element if there's a message
	if (getElement ('hashover-message').textContent !== '') {
		showMessage ();
	}
};

// Initiate HashOver
HashOver.init ();

settings.php
<?php namespace HashOver;

// Copyright (C) 2010-2017 Jacob Barkdull
// This file is part of HashOver.
//
// I, Jacob Barkdull, hereby release this work into the public domain.
// This applies worldwide. If this is not legally possible, I grant any
// entity the right to use this work for any purpose, without any
// conditions, unless such conditions are required by law.
//
//--------------------
//
// IMPORTANT NOTICE:
//
// To retain your settings and maintain proper functionality, when
// downloading or otherwise upgrading to a new version of HashOver it
// is important that you preserve this file, unless directed otherwise.
//
// It is also important to choose UNIQUE values for the encryption key,
// admin name, and admin password, as not doing so puts HashOver at
// risk of being hijacked. Allowing someone to delete comments and/or
// edit existing comments to post spam, impersonate you or your
// visitors in order to push some sort of agenda/propaganda, to defame
// you or your visitors, or to imply endorsement of some product(s),
// service(s), and/or political ideology.


class Settings
{
	// Required setup
	public    $notificationEmail	= 'test@163.com';	// E-mail for notification of new comments
	protected $encryptionKey	= 'komencom';			// Unique encryption key
	protected $adminName		= 'root';			// Login name to gain admin rights (case-sensitive)
	protected $adminPassword	= 'root';			// Login password to gain admin rights (case-sensitive)

	// Primary settings
	public $language		= 'zh-cn';			// UI language, for example 'en', 'de', etc. 'auto' to use system locale
	public $theme			= 'komen';			// Comment Cascading Style Sheet (CSS)
	public $usesModeration		= false;			// Whether comments must be approved before they appear to other visitors
	public $dataFormat		= 'xml';			// Format comments will be stored in; options: xml, json, sql
	public $defaultName		= 'Anonymous';			// Default name to use when one isn't given
	public $allowsImages		= true;				// Whether external image URLs wrapped in [img] tags are embedded
	public $allowsLogin		= false;				// Whether users can login and logout (when false form cookies are still set)
	public $allowsLikes		= false;				// Whether a "Like" link is displayed
	public $allowsDislikes		= false;			// Whether a "Dislike" link is displayed; allowing Reddit-style voting
	public $usesAJAX		= true;				// Whether AJAX is used for posting, editing, and loading comments
	public $collapsesUI		= false;			// Whether the comment form, thread, and end links are all initially hidden
	public $collapsesComments	= false;				// Whether to hide comments and display a link to show them
	public $collapseLimit		= 3;				// Number of comments that aren't hidden
	public $replyMode		= 'thread';			// Whether to display replies as a 'thread' or as a 'stream'
	public $streamDepth		= 3;				// In stream mode, the number of reply indentions to allow before the thread flattens
	public $popularityThreshold	= 5;				// Minimum likes a comment needs to be popular
	public $popularityLimit		= 2;				// Number of comments allowed to become popular

	// Date and Time settings
	public $serverTimezone		= 'America/Los_Angeles';	// Server timezone
	public $usesUserTimezone	= false;				// Whether comment dates should use the user's timezone (JavaScript-mode)
	public $usesShortDates		= false;				// Whether comment dates are shortened, for example "X days ago"
	public $timeFormat		= 'h:i a';			// Time format, use 'H:i' for 24-hour format (see: http://php.net/manual/en/function.date.php)
	public $dateFormat		= 'F jS, Y';			// Date format (see: http://php.net/manual/en/function.date.php)

	// Field options, use true/false to enable/disable a field,
	// use 'required' to require a field be properly filled
	public $fieldOptions = array (
		'name'     => true,
		'password' => false,
		'email'    => true,
		'website'  => true
	);

	// Behavior settings
	public $displaysTitle		= true;				// Whether page title is shown or not
	public $formPosition		= 'bottom';			// Position for primary form; options: 'top' or 'bottom'
	public $usesAutoLogin		= true;				// Whether a user's first comment automatically logs them in
	public $showsReplyCount		= false;				// Whether to show reply count separately from total
	public $countIncludesDeleted	= true;				// Whether comment counts should include deleted comments
	public $iconMode		= 'image';			// How to display avatar icons (either 'image', 'count' or 'none')
	public $iconSize		= '32';				// Size of Gravatar icons in pixels
	public $imageFormat		= 'png';			// Format for icons and other images (use 'svg' for HDPI)
	public $usesLabels		= false;			// Whether to display labels above inputs
	public $usesCancelButtons	= true;				// Whether forms have "Cancel" buttons
	public $appendsCSS		= true;				// Whether to automatically add a CSS <link> element to the page <head>
	public $displaysRSSLink		= false;				// Whether a comment RSS feed link is displayed

	// Technical settings
	public $loginMethod		= 'defaultLogin';		// Login method class for handling user login information
	public $setsCookies		= true;				// Whether cookies are enabled
	public $secureCookies		= false;			// Whether cookies set over secure HTTPS will only be transmitted over HTTPS
	public $storesIPAddress		= false;			// Whether to store users' IP addresses
	public $allowsUserReplies	= false;			// Whether given e-mails are sent as reply-to address to users
	public $noreplyEmail		= 'noreply@example.com';	// E-mail used when no e-mail is given
	public $spamDatabase		= 'remote';			// Whether to use a remote or local spam database
	public $spamCheckModes		= 'php';			// Perform IP spam check in 'javascript' or 'php' mode, or 'both'
	public $gravatarDefault		= 'custom';			// Gravatar theme to use ('custom', 'identicon', 'monsterid', 'wavatar', or 'retro')
	public $gravatarForce		= true;			// Whether to force the themed Gravatar images instead of an avatar image
	public $minifiesJavaScript	= true;			// Whether JavaScript output should be minified
	public $minifyLevel		= 4;				// How much to minify JavaScript code, options: 1, 2, 3, 4
	public $enablesAPI		= true;				// API: true = fully-enabled, false = fully disabled, or array of modes
	public $latestMax		= 10;				// Maximum number of comments to save as latest comments
	public $latestTrimWidth		= 100;				// Number of characters to trim latest comments to, 0 for no trim
	public $userDeletionsUnlink	= false;			// Whether user deleted files are actually unlinked from the filesystem

	// Types of images allowed to be embedded in comments
	public $imageTypes = array (
		'jpeg',
		'jpg',
		'png',
		'gif'
	);

	// External domains allowed to remotely load HashOver scripts
	public $allowedDomains = array (
		// '*.example.com',
		// '*.example.org',
		// '*.example.net'
	);

	// General database options
	public $databaseType		= 'sqlite';			// Type of database, sqlite or mysql
	public $databaseName		= 'hashover-pages';		// Database name

	// SQL database options
	public $databaseHost		= 'localhost';			// Database host name
	public $databaseUser		= 'root';			// Database login user
	public $databasePassword	= 'password';			// Database login password
	public $databaseCharset		= 'utf8';			// Database character set

	// Automated settings
	public $isMobile		= true;

	// Technical settings placeholders
	public $rootDirectory;
	public $httpRoot;
	public $httpScripts;
	public $httpImages;
	public $cookieExpiration;
	public $domain;

	public function __construct ()
	{
		// Set server timezone
		date_default_timezone_set ($this->serverTimezone);

		// Set encoding
		mb_internal_encoding ('UTF-8');

		// Get parent directory
		$root_directory = dirname (__DIR__);

		// Get HTTP parent directory
		$document_root = realpath ($_SERVER['DOCUMENT_ROOT']);
		$http_directory = mb_substr ($root_directory, mb_strlen ($document_root));

		// Replace backslashes with forwardslashes on Windows
		if (DIRECTORY_SEPARATOR === '\\') {
			$http_directory = str_replace ('\\', '/', $http_directory);
		}

		// Determine HTTP or HTTPS
		$protocol = ($this->isHTTPS () ? 'https' : 'http') . '://';

		// Technical settings
		$this->rootDirectory	= $root_directory;		// Root directory for script
		$this->httpRoot		= $http_directory;		// Root directory for HTTP
		$this->cookieExpiration	= time () + 60 * 60 * 24 * 30;	// Cookie expiration date
		$this->domain		= $_SERVER['HTTP_HOST'];	// Domain name for refer checking & notifications
		$this->absolutePath	= $protocol . $this->domain;	// Absolute path or remote access

		// Synchronize settings
		$this->syncSettings ();
	}

	function isHTTPS ()
	{
		// The connection is HTTPS if server says so
		if (!empty ($_SERVER['HTTPS']) and $_SERVER['HTTPS'] !== 'off') {
			return true;
		}

		// Assume the connection is HTTPS on standard SSL port
		if ($_SERVER['SERVER_PORT'] == 443) {
			return true;
		}

		return false;
	}

	// Synchronizes specific settings after remote changes
	public function syncSettings ()
	{
		// Disable likes and dislikes if cookies are disabled
		if ($this->setsCookies === false) {
			$this->allowsLikes = false;
			$this->allowsDislikes = false;
		}

		// Setup default field options
		foreach (array ('name', 'password', 'email', 'website') as $field) {
			if (!isset ($this->fieldOptions[$field])) {
				$this->fieldOptions[$field] = true;
			}
		}

		// Disable password if name is disabled
		if ($this->fieldOptions['name'] === false) {
			$this->fieldOptions['password'] = false;
		}

		// Disable login if name or password is disabled
		if ($this->fieldOptions['name'] === false
		    or $this->fieldOptions['password'] === false)
		{
			$this->allowsLogin = false;
		}

		// Disable autologin if login is disabled
		if ($this->allowsLogin === false) {
			$this->usesAutoLogin = false;
		}

		$this->httpScripts	= $this->httpRoot . '/scripts';	// Script directory for HTTP
		$this->httpImages	= $this->httpRoot . '/images';	// Image directory for HTTP
	}
}

writecomments.php
<?php namespace HashOver;

// Copyright (C) 2010-2017 Jacob Barkdull
// This file is part of HashOver.
//
// HashOver is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// HashOver is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with HashOver.  If not, see <http://www.gnu.org/licenses/>.


// Display source code
if (basename ($_SERVER['PHP_SELF']) === basename (__FILE__)) {
	if (isset ($_GET['source'])) {
		header ('Content-type: text/plain; charset=UTF-8');
		exit (file_get_contents (basename (__FILE__)));
	} else {
		exit ('<b>HashOver</b>: This is a class file.');
	}
}

class WriteComments extends PostData
{
	protected $setup;
	protected $encryption;
	protected $mode;
	protected $readComments;
	protected $formatData;
	protected $locale;
	protected $cookies;
	protected $login;
	protected $misc;
	protected $spamCheck;
	protected $metalevels;
	protected $headers;
	protected $userHeaders;
	protected $kickbackURL;
	protected $name = '';
	protected $password = '';
	protected $loginHash = '';
	protected $email = '';
	protected $website = '';
	protected $commentData = array ();
	protected $urls = array ();

	// Fake inputs used as spam trap fields
	protected $trapFields = array (
		'summary',
		'age',
		'lastname',
		'address',
		'zip'
	);

	// Characters to search for and replace with in comments
	protected $dataSearch = array (
		'\\',
		'"',
		'<',
		'>',
		"\r\n",
		"\r",
		"\n",
		'  '
	);

	// Character replacements
	protected $dataReplace = array (
		'&#92;',
		'&quot;',
		'&lt;',
		'&gt;',
		PHP_EOL,
		PHP_EOL,
		PHP_EOL,
		'&nbsp; '
	);

	// HTML tags to allow in comments
	protected $htmlTagSearch = array (
		'b',
		'big',
		'blockquote',
		'code',
		'em',
		'i',
		'li',
		'ol',
		'pre',
		's',
		'small',
		'strong',
		'sub',
		'sup',
		'u',
		'ul'
	);

	// HTML tags to automatically close
	protected $closeTags = array (
		'b',
		'i',
		'u',
		's',
		'li',
		'pre',
		'blockquote',
		'ul',
		'ol'
	);

	// Unprotected fields to update when editing a comment
	protected $editableFields = array (
		'body',
		'name',
		'notifications',
		'website'
	);

	// Password protected fields
	protected $protectedFields = array (
		'password',
		'login_id',
		'email',
		'encryption',
		'email_hash'
	);

	// Possible comment status options
	protected $statusOptions = array (
		'approved',
		'pending',
		'deleted'
	);

	public function __construct (Setup $setup, ReadComments $read_comments)
	{
		parent::__construct ();

		$this->setup = $setup;
		$this->encryption = $setup->encryption;
		$this->mode = $setup->usage['mode'];
		$this->readComments = $read_comments;
		$this->formatData = $this->readComments->data;
		$this->locale = new Locale ($setup);
		$this->cookies = new Cookies ($setup);
		$this->login = new Login ($setup);
		$this->misc = new Misc ($this->mode);
		$this->spamCheck = new SpamCheck ($setup);

		$this->metalevels = array (
			$setup->dir,
			$setup->getAbsolutePath ('pages')
		);

		// Default email headers
		$this->setHeaders ($setup->noreplyEmail);

		// Check if posting from remote domain
		if ($this->remoteAccess === true) {
			// If so, use absolute path
			$this->kickbackURL = $setup->pageURL;
		} else {
			// If not, use relative path
			$this->kickbackURL = $setup->filePath;
		}

		// Add URL queries to kickback URL
		if (!empty ($setup->URLQueries)) {
			$this->kickbackURL .= '?' . $setup->URLQueries;
		}
	}

	// Encodes HTML entities
	protected function encodeHTML ($value)
	{
		return htmlentities ($value, ENT_COMPAT, 'UTF-8', false);
	}

	// Set mail headers
	protected function setHeaders ($email, $user = true)
	{
		$this->headers  = 'Content-Type: text/plain; charset=UTF-8' . "\r\n";
		$this->headers .= 'From: ' . $email . "\r\n";
		$this->headers .= 'Reply-To: ' . $email;

		// Set commenter's headers to new value as well
		if ($user === true) {
			$this->userHeaders = $this->headers;
		}
	}

	protected function kickback ($text = '', $error = false, $anchor = 'comments')
	{
		$message_type = ($error) ? 'error' : 'message';

		// Return error as JSON if request is AJAX
		if ($this->viaAJAX === true) {
			if (!empty ($text)) {
				echo json_encode (array (
					'message' => $text,
					'type' => $message_type
				));
			}

			return;
		}

		// Set cookie to specified message or error
		if (!empty ($text)) {
			$this->cookies->set ($message_type, $text);
		}

		// Set header to redirect user to previous page
		header ('Location: ' . $this->kickbackURL . '#' . $anchor);
	}

	// Confirm that attempted actions are to existing comments
	protected function verifyFile ($file)
	{
		if (!empty ($_POST[$file])) {
			$comment_file =(string) $_POST[$file];

			// Return true if POST file is in comment list
			if (in_array ($comment_file, $this->readComments->commentList, true)) {
				return $comment_file;
			}

			// Set cookies to indicate failure
			if ($this->viaAJAX !== true) {
				$this->cookies->setFailedOn ('comment', $this->replyTo, false);
			}
		}

		// Throw exception as error message
		throw new \Exception ($this->locale->text['comment-needed']);

		return false;
	}

	protected function checkForSpam ()
	{
		// Check trap fields
		foreach ($this->trapFields as $name) {
			if (!empty ($_POST[$name])) {
				// Block for filing trap fields
				throw new \Exception ('You are blocked!');
				return false;
			}
		}

		// Check user's IP address against local blocklist
		if ($this->spamCheck->checkList () === true) {
			throw new \Exception ('You are blocked!');
			return false;
		}

		// Whether to check for spam in current mode
		if ($this->setup->spamCheckModes === 'both'
		    or $this->setup->spamCheckModes === $this->mode)
		{
			// Check user's IP address against local or remote database
			if ($this->spamCheck->{$this->setup->spamDatabase}() === true) {
				throw new \Exception ('You are blocked!');
				return false;
			}

			// Throw any error message as exception
			if (!empty ($this->spamCheck->error)) {
				throw new \Exception ($this->spamCheck->error);
				return false;
			}
		}

		return true;
	}

	// Set cookies
	public function login ($kickback = true)
	{
		try {
			// Log the user in
			$this->login->setLogin ();

			// Kick visitor back
			if ($kickback !== false) {
				$this->kickback ($this->locale->text['logged-in']);
			}

		} catch (\Exception $error) {
			throw new \Exception ($error->getMessage ());
			return false;
		}

		return true;
	}

	// Expire cookies
	public function logout ()
	{
		// Log the user out
		$this->login->clearLogin ();

		// Kick visitor back
		$this->kickback ($this->locale->text['logged-out']);

		return true;
	}

	protected function addLatestComment ($file)
	{
		if ($this->formatData->storageMode !== 'flat-file') {
			return false;
		}

		foreach ($this->metalevels as $level => $metafile) {
			$metafile .= '/.metadata';
			$metadata = array ();
			$data = array ('latest' => array ());

			if ($level === 0) {
				$metadata['title'] = $this->setup->pageTitle;
				$metadata['url'] = $this->setup->pageURL;
				$metadata['status'] = 'open';
			}

			if (!file_exists ($metafile) or !is_writable ($metafile)) {
				continue;
			}

			$contents = @file_get_contents ($metafile);
			$data = @json_decode ($contents, true);

			if ($contents === false or $data === null) {
				continue;
			}

			if (!isset ($data['status']) or !is_string ($data['status'])) {
				$data['status'] = 'open';
			}

			if (!isset ($data['latest']) or !is_array ($data['latest'])) {
				$data['latest'] = array ();
			}

			if ($level === 0) {
				$metadata['status'] = $data['status'];
				array_unshift ($data['latest'], (string) $file);
			} else {
				$comment_directory = basename ($this->metalevels[0]);
				array_unshift ($data['latest'], $comment_directory . '/' . $file);
			}

			$latest_count = count ($data['latest']);

			if ($latest_count >= 10) {
				if ($latest_count >= $this->setup->latestMax) {
					$max = max (10, $this->setup->latestMax);
					$data['latest'] = array_slice ($data['latest'], 0, $max);
				}
			}

			$metadata['latest'] = $data['latest'];

			// Save metadata
			$this->formatData->saveMetadata ($metadata, $metafile);
		}
	}

	protected function removeFromLatest ($file)
	{
		if ($this->formatData->storageMode !== 'flat-file') {
			return false;
		}

		foreach ($this->metalevels as $level => $metafile) {
			$metafile .= '/.metadata';

			if (!file_exists ($metafile) or !is_writable ($metafile)) {
				continue;
			}

			$contents = @file_get_contents ($metafile);
			$metadata = @json_decode ($contents, true);

			if ($contents === false or $metadata === null) {
				continue;
			}

			$file = basename ($file);
			$latest = array ();

			for ($key = 0, $length = count ($metadata['latest']); $key < $length; $key++) {
				$comment_directory = basename ($this->metalevels[0]);
				$comment = ($level === 0) ? $file : $comment_directory . '/' . $file;

				if ($metadata['latest'][$key] !== $comment) {
					$latest[] = $metadata['latest'][$key];
				}
			}

			$metadata['latest'] = $latest;
			$this->formatData->saveMetadata ($metadata, $metafile);
		}
	}

	// User comment authentication
	protected function commentAuthentication ()
	{
		// Verify file exists
		$file = $this->verifyFile ('file');

		// Authentication data
		$auth = array (
			// Assume no authorization by default
			'authorized' => false,
			'user-owned' => false,

			// Read original comment
			'comment' => $this->formatData->read ($file)
		);

		// Return authorization data if we fail to get comment
		if ($auth['comment'] === false) {
			return $auth;
		}

		// Check if we have both required passwords
		if (!empty ($this->postData['password'])
		    and !empty ($auth['comment']['password']))
		{
			// If so, get the user input password
			$user_password = $this->encodeHTML ($this->postData['password']);

			// Get the comment password
			$comment_password = $auth['comment']['password'];

			// Attempt to compare the two passwords
			$auth['user-owned'] = $this->encryption->verifyHash ($user_password, $comment_password);
		}

		// Set general authorization state
		$auth['authorized'] = ($auth['user-owned'] or $this->login->userIsAdmin);

		return $auth;
	}

	// Delete comment
	public function deleteComment ()
	{
		try {
			// Authenticate user password
			$auth = $this->commentAuthentication ();

			// Check if user is authorized
			if ($auth['authorized'] === true) {
				// If so, delete the comment file
				if ($this->formatData->delete ($this->file, $this->setup->userDeletionsUnlink)) {
					$this->removeFromLatest ($this->file);

					// And kick visitor back with comment deletion message
					$this->kickback ($this->locale->text['comment-deleted']);

					return true;
				}
			}

			// Otherwise sleep for 5 seconds
			sleep (5);

			// Then kick visitor back with comment posting error
			$this->kickback ($this->locale->text['post-fail'], true);

		} catch (\Exception $error) {
			// On exception kick visitor back with error
			$this->kickback ($error->getMessage (), true);
		}

		return false;
	}

	// Closes all allowed HTML tags
	protected function tagCloser ($tags, $html)
	{
		for ($tc = 0, $tcl = count ($tags); $tc < $tcl; $tc++) {
			// Count opening and closing tags
			$open_tags = mb_substr_count ($html, '<' . $tags[$tc] . '>');
			$close_tags = mb_substr_count ($html, '</' . $tags[$tc] . '>');

			// Check if opening and closing tags aren't equal
			if ($open_tags !== $close_tags) {
				// Add closing tags to end of comment
				while ($open_tags > $close_tags) {
					$html .= '</' . $tags[$tc] . '>';
					$close_tags++;
				}

				// Remove closing tags for unopened tags
				while ($close_tags > $open_tags) {
					$html = preg_replace ('/<\/' . $tags[$tc] . '>/i', '', $html, 1);
					$close_tags--;
				}
			}
		}

		return $html;
	}

	// Extract URLs for later injection
	protected function urlExtractor ($groups)
	{
		$link_number = count ($this->urls);
		$this->urls[] = $groups[1];

		return 'URL[' . $link_number . ']';
	}

	// Escapes HTML inside of <code> tags and markdown code blocks
	protected function codeEscaper ($groups)
	{
		return $groups[1] . htmlspecialchars ($groups[2], null, null, false) . $groups[3];
	}

	// Setup and test for necessary comment data
	protected function setupCommentData ($editing = false)
	{
		// Check if setup is for a comment edit
		if ($editing === true) {
			// If so, mimic normal user login
			$this->login->prepareCredentials ();
			$this->login->updateCredentials ();

			// Default status
			$isModerated = $this->setup->usesModeration;
			$default_service = ($isModerated === true) ? 'pending' : 'approved';

			// Check for status in POST data
			if (!empty ($this->postData['status'])) {
				// If found, use it
				$status = $this->postData['status'];
			} else {
				// If it's missing use default
				$status = $default_service;
			}

			// Check if user is admin
			if ($this->login->userIsAdmin === true) {
				// If so, check if status is allowed
				if (in_array ($this->postData['status'], $this->statusOptions, true)) {
					// If so, use it
					$this->commentData['status'] = $this->postData['status'];
				} else {
					// If not, use default
					$this->commentData['status'] = $default_service;
				}
			} else {
				// If not, store default status
				$this->commentData['status'] = $default_service;
			}
		} else {
			// If not, setup initial login information
			if ($this->login->userIsLoggedIn !== true) {
				$this->login->setCredentials ();
			}
		}

		// Check if required fields have values
		$this->login->validateFields ();

		// Post fails when comment is empty
		if (empty ($this->postData['comment'])) {
			// Set cookies to indicate failure
			if ($this->viaAJAX !== true) {
				$this->cookies->setFailedOn ('comment', $this->replyTo);
			}

			// Set reply cookie
			if (!empty ($this->replyTo)) {
				// Throw exception about reply requirement
				throw new \Exception ($this->locale->text['reply-needed']);

				return false;
			}

			// Throw exception about comment requirement
			throw new \Exception ($this->locale->text['comment-needed']);

			return false;
		}

		// Escape disallowed characters in login information
		$this->name = $this->encodeHTML ($this->login->name);
		$this->password = $this->encodeHTML ($this->login->password);
		$this->loginHash = $this->encodeHTML ($this->login->loginHash);
		$this->email = $this->encodeHTML ($this->login->email);
		$this->website = $this->encodeHTML ($this->login->website);

		// Set mail headers to user's e-mail address
		if (!empty ($this->email)) {
			$this->setHeaders ($this->email, false);
		}

		// Trim leading and trailing white space
		$clean_code = $this->postData['comment'];

		// Extract URLs from comment
		$clean_code = preg_replace_callback ('/((http|https|ftp):\/\/[a-z0-9-@:;%_\+.~#?&\/=]+)/i', 'self::urlExtractor', $clean_code);

		// Escape HTML tags
		$clean_code = str_ireplace ($this->dataSearch, $this->dataReplace, $clean_code);

		// Unescape allowed HTML tags
		foreach ($this->htmlTagSearch as $tag) {
			$escaped_tags = array ('&lt;' . $tag . '&gt;', '&lt;/' . $tag . '&gt;');
			$text_tags = array ('<' . $tag . '>', '</' . $tag . '>');
			$clean_code = str_ireplace ($escaped_tags, $text_tags, $clean_code);
		}

		// Collapse multiple newlines to three maximum
		$clean_code = preg_replace ('/' . PHP_EOL . '{3,}/', str_repeat (PHP_EOL, 3), $clean_code);

		// Close <code> tags
		$clean_code = $this->tagCloser (array ('code'), $clean_code);

		// Escape HTML inside of <code> tags and markdown code blocks
		$clean_code = preg_replace_callback ('/(<code>)(.*?)(<\/code>)/is', 'self::codeEscaper', $clean_code);
		$clean_code = preg_replace_callback ('/(```)(.*?)(```)/is', 'self::codeEscaper', $clean_code);

		// Close remaining tags
		$clean_code = $this->tagCloser ($this->closeTags, $clean_code);

		// Inject original URLs back into comment
		$clean_code = preg_replace_callback ('/URL\[([0-9]+)\]/', function ($groups) {
			$url_key = $groups[1];
			$url = $this->urls[$url_key];

			return $url . ' ';
		}, $clean_code);

		// Store clean code
		$this->commentData['body'] = $clean_code;

		// Store posting date
		$this->commentData['date'] = date (DATE_ISO8601);

		// Check if name is enabled and isn't empty
		if ($this->setup->fieldOptions['name'] !== false) {
			// Store name
			if (!empty ($this->name)) {
				$this->commentData['name'] = $this->name;
			}
		}

		// Store password and login ID if a password is given
		if ($this->setup->fieldOptions['password'] !== false) {
			if (!empty ($this->password)) {
				$this->commentData['password'] = $this->password;

				// Store login ID if login hash is non-empty
				if (!empty ($this->loginHash)) {
					$this->commentData['login_id'] = $this->loginHash;
				}
			}
		}

		// Store e-mail if one is given
		if ($this->setup->fieldOptions['email'] !== false) {
			if (!empty ($this->email)) {
				$encryption_keys = $this->encryption->encrypt ($this->email);
				$this->commentData['email'] = $encryption_keys['encrypted'];
				$this->commentData['encryption'] = $encryption_keys['keys'];
				$this->commentData['email_hash'] = md5 (mb_strtolower ($this->email));

				// Set e-mail subscription if one is given
				$this->commentData['notifications'] = !empty ($_POST['subscribe']) ? 'yes' : 'no';
			}
		}

		// Store website URL if one is given
		if ($this->setup->fieldOptions['website'] !== false) {
			if (!empty ($this->website)) {
				$this->commentData['website'] = $this->website;
			}
		}

		// Store user IP address if setup to and one is given
		if ($this->setup->storesIPAddress === true) {
			if (!empty ($_SERVER['REMOTE_ADDR'])) {
				$this->commentData['ipaddr'] = $this->misc->makeXSSsafe ($_SERVER['REMOTE_ADDR']);
			}
		}

		return true;
	}

	public function editComment ()
	{
		try {
			// Authenticate user password
			$auth = $this->commentAuthentication ();

			// Check if user is authorized
			if ($auth['authorized'] === true) {
				// Check if user is admin
				if ($this->login->userIsAdmin === true) {
					// If so, set status for update
					$update_fields[] = 'status';
				} else {
					// If not, login normal user with edited credentials
					$this->login (false);
				}

				// Setup necessary comment data
				$this->setupCommentData (true);

				// Set initial fields for update
				$update_fields = $this->editableFields;

				// Only set protected fields for update if passwords match
				if ($auth['user-owned'] === true) {
					$update_fields = array_merge ($update_fields, $this->protectedFields);
				}

				// Update login information and comment
				foreach ($update_fields as $key) {
					if (!empty ($this->commentData[$key])) {
						$auth['comment'][$key] = $this->commentData[$key];
					} else {
						unset ($auth['comment'][$key]);
					}
				}

				// Attempt to write edited comment
				if ($this->formatData->save ($auth['comment'], $this->file, true)) {
					// If successful, check if request is via AJAX
					if ($this->viaAJAX === true) {
						// If so, return the comment data
						return array (
							'file' => $this->file,
							'comment' => $auth['comment']
						);
					}

					// Otherwise kick visitor back to posted comment
					$this->kickback ('', false, 'c' . str_replace ('-', 'r', $this->file));

					return true;
				}
			}

			// Otherwise sleep for 5 seconds
			sleep (5);

			// Then kick visitor back with comment posting error
			$this->kickback ($this->locale->text['post-fail'], true);

		} catch (\Exception $error) {
			// On exception kick visitor back with error
			$this->kickback ($error->getMessage (), true);
		}

		return false;
	}

	protected function indentedWordwrap ($text)
	{
		if (PHP_EOL !== "\r\n") {
			$text = str_replace (PHP_EOL, "\r\n", $text);
		}

		$text = wordwrap ($text, 66, "\r\n", true);
		$paragraphs = explode ("\r\n\r\n", $text);
		$paragraphs = str_replace ("\r\n", "\r\n    ", $paragraphs);

		array_walk ($paragraphs, function (&$paragraph) {
			$paragraph = '    ' . $paragraph;
		});

		return implode ("\r\n\r\n", $paragraphs);
	}

	protected function sendNotification ($from, $comment, $reply = '', $permalink, $email, $header)
	{
		$subject  = $this->setup->domain . ' - New ';
		$subject .= !empty ($reply) ? 'Reply' : 'Comment';

		// Message body to original poster
		$message  = 'From ' . $from . ":\r\n\r\n";
		$message .= $comment . "\r\n\r\n";
		$message .= 'In reply to:' . "\r\n\r\n" . $reply . "\r\n\r\n" . '----' . "\r\n\r\n";
		$message .= 'Permalink: ' . $this->setup->pageURL . '#' . $permalink . "\r\n\r\n";
		$message .= 'Page: ' . $this->setup->pageURL;

		// Send e-mail
		mail ($email, $subject, $message, $header);
	}

	protected function writeComment ($comment_file)
	{
		// Write comment to file
		if ($this->formatData->save ($this->commentData, $comment_file)) {
			$this->addLatestComment ($comment_file);

			// Send notification e-mails
			$permalink = 'c' . str_replace ('-', 'r', $comment_file);
			$from_line = !empty ($this->name) ? $this->name : $this->setup->defaultName;
			$mail_comment = html_entity_decode (strip_tags ($this->commentData['body']), ENT_COMPAT, 'UTF-8');
			$mail_comment = $this->indentedWordwrap ($mail_comment);
			$webmaster_reply = '';

			// Notify commenter of reply
			if (!empty ($this->replyTo)) {
				$reply_comment = $this->formatData->read ($this->replyTo);
				$reply_body = html_entity_decode (strip_tags ($reply_comment['body']), ENT_COMPAT, 'UTF-8');
				$reply_body = $this->indentedWordwrap ($reply_body);
				$reply_name = !empty ($reply_comment['name']) ? $reply_comment['name'] : $this->setup->defaultName;
				$webmaster_reply = 'In reply to ' . $reply_name . ':' . "\r\n\r\n" . $reply_body . "\r\n\r\n";

				if (!empty ($reply_comment['email']) and !empty ($reply_comment['encryption'])) {
					$reply_email = $this->encryption->decrypt ($reply_comment['email'], $reply_comment['encryption']);

					if ($reply_email !== $this->email
					    and !empty ($reply_comment['notifications'])
					    and $reply_comment['notifications'] === 'yes')
					{
						if ($this->setup->allowsUserReplies === true) {
							$this->userHeaders = $this->headers;

							// Add user's e-mail address to "From" line
							if (!empty ($this->email)) {
								$from_line .= ' <' . $this->email . '>';
							}
						}

						// Message body to original poster
						$reply_message  = 'From ' . $from_line . ":\r\n\r\n";
						$reply_message .= $mail_comment . "\r\n\r\n";
						$reply_message .= 'In reply to:' . "\r\n\r\n" . $reply_body . "\r\n\r\n" . '----' . "\r\n\r\n";
						$reply_message .= 'Permalink: ' . $this->setup->pageURL . '#' . $permalink . "\r\n\r\n";
						$reply_message .= 'Page: ' . $this->setup->pageURL;

						// Send
						mail ($reply_email, $this->setup->domain . ' - New Reply', $reply_message, $this->userHeaders);
					}
				}
			}

			// Notify webmaster via e-mail
			if ($this->email !== $this->setup->notificationEmail) {
				// Add user's e-mail address to "From" line
				if (!empty ($this->email)) {
					$from_line .= ' <' . $this->email . '>';
				}

				$webmaster_message  = 'From ' . $from_line . ":\r\n\r\n";
				$webmaster_message .= $mail_comment . "\r\n\r\n";
				$webmaster_message .= $webmaster_reply . '----' . "\r\n\r\n";
				$webmaster_message .= 'Permalink: ' . $this->setup->pageURL . '#' . $permalink . "\r\n\r\n";
				$webmaster_message .= 'Page: ' . $this->setup->pageURL;

				// Send
				// mail ($this->setup->notificationEmail, 'New Comment', $webmaster_message, $this->headers);
			}

			// Set/update user login cookie
			if ($this->setup->usesAutoLogin !== false) {
				$this->login (false);
			}

			// Return the comment data on success via AJAX
			if ($this->viaAJAX === true) {
				// Increase comment count(s)
				$this->readComments->countComment ($comment_file);

				return array (
					'file' => $comment_file,
					'comment' => $this->commentData
				);
			}

			// Kick visitor back to comment
			$this->kickback ('', false, $permalink);

			return true;
		}

		// Kick visitor back with an error on failure
		$this->kickback ($this->locale->text['post-fail'], true);
		return false;
	}

	public function postComment ()
	{
		try {
			// Test for necessary comment data
			$this->setupCommentData ();

			// Set comment file name
			if (isset ($this->replyTo)) {
				// Verify file exists
				$this->verifyFile ('reply-to');

				// Rename file for reply
				$comment_file = $this->replyTo . '-' . $this->readComments->threadCount[$this->replyTo];
			} else {
				$comment_file = $this->readComments->primaryCount;
			}

			// Check if comment is SPAM
			$this->checkForSpam ();

			// Check if comment thread exists
			$this->formatData->checkThread ();

			// Write the comment file
			return $this->writeComment ($comment_file);

		} catch (\Exception $error) {
			// On exception kick visitor back with error
			$this->kickback ($error->getMessage (), true);
		}

		return false;
	}
}

layout.html
<div class="hashover-header">
	{hashover:avatar}
	{hashover:name}
	<div class="hashover-date">
		{hashover:date}
	</div>
</div>

<div class="hashover-balloon">
	<div id="hashover-content-{hashover:permalink}" class="hashover-content">
		{hashover:thread-link}
		{hashover:comment}
	</div>

	<div class="hashover-footer">
		<span class="hashover-buttons">
			{hashover:like-link}
			{hashover:dislike-link}
			{hashover:edit-link}
			{hashover:reply-link}
		</span>
	</div>
</div>

style.css
#hashover-count-wrapper {
	color: #6E7173;
  line-height: 2.7;
  margin-top: 0;
  font-size: 16px;
  border-bottom: 1px solid #ddd;
  display: block;
}

#hashover-sort-div .hashover-comment {
	padding: 22px 0 0;
  border-top: 1px solid #ddd;
}

#hashover .hashover-avatar {
	float: left;
  margin: 1px 10px 0 0;
  border: 1px solid #ddd;
  padding: 1px;
}

#hashover .hashover-avatar > div {
	width: 32px;
	height: 32px;
}

#hashover .hashover-comment-name {
	font-weight: bold;
  font-style: normal;
  line-height: 1.2;
  font-size: 14px;
}

#hashover .hashover-date > a {
	color: #999;
  font-size: .92857em;
}

#hashover .hashover-comment-reply {
  float: right;
  margin-top: -39px;
  font-size: .92857em;
}

#hashover a {
	color: #6E7173;
  text-decoration: none;
  -webkit-transition: all .1s ease-in;
  -moz-transition: all .1s ease-in;
  -o-transition: all .1s ease-in;
  transition: all .1s ease-in;
}

#hashover .hashover-content {
  line-height: 1.5;
  word-wrap: break-word;
  padding: 10px 40px 10px 0;
}

#hashover .hashover-content p {
	display: inline-block;
}

#hashover .hashover-main-title {
  color: #6E7173;
  line-height: 2.7;
  margin-top: 0;
  font-size: 16px;
  border-bottom: 1px solid #ddd;
  display: block;
  margin-bottom: .8em;
}

#hashover #hashover-requiredFields,
#hashover .hashover-formatting-message,
#hashover #hashover-end-links,
#hashover .hashover-form-links {
  display: none;
}

#hashover .hashover-inputs {
  width: 204px;
  float: right;
  position: relative;
  overflow: hidden;
  background-position: right top;
}

#hashover .hashover-input-cell {
  margin: 9px 0;
}

#hashover .hashover-input-cell input {
  padding: 8px 6px;
  height: 36px;
  border: solid 1px #D4D4D4;
  background: #fdfdfd;
  padding-left: 45px;
  color: #555;
  width: 100%;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  outline: none;
}

#hashover .hashover-textarea {
      padding: 10px;
    overflow: auto;
    line-height: 1.8;
    font-size: 14px;
    color: rgb(85, 85, 85);
    width: 560px;
    margin: 9px 0px;
    resize: none;
    font-family: inherit;
}

