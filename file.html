// src/engine/board.js
class GameBoard {
  constructor() {
    this.objects = [];
    this.cnt = [];
  }

  add(obj) {
    this.objects.push(obj);
    this.cnt[obj.type] = (this.cnt[obj.type || 0] + 1);
    return obj;
  }

  remove(obj) {
    const isAlive = this.removed.indexOf(obj) === -1;
    isAlive && this.removed.push(obj);
    return isAlive;
  }

  resetRemoved() {
    this.removed = [];
  }

  finalizeRemoved() {
    for (let item of this.removed) {
      if (this.objects.indexOf(item) !== -1) {
        this.cnt[item.type]--;
        this.objects.splice(this.objects.indexOf(item), 1);
      }
    }
  }

  iterate(funcName, ...rest) {
    for (let item of this.objects) {
      item[funcName].apply(item, rest);
    }
  }

  detect(func) {
    for (let item of this.objects) {
      if(func.call(item)) {
        return item;
      }
    }

    return false;
  }

  step(dt) {
    this.resetRemoved();
    this.iterate('step', dt);
    this.finalizeRemoved();
  }

  draw(ctx) {
    this.iterate('draw', ctx);
  }

  overlap(o1, o2) {
    return !((o1.y + o1.h -1  < o2.y) || (o1.y > o2.y + o2.h -1) ||
      (o1.x + o1.w -1  < o2.x) || (o1.x > o2.x + o2.w -1));
  }

  collide(obj, type) {
    const that = this;
    return this.detect(function() {
      if (obj !== this) {
        const col = (!type || this.type & type) && that.overlap(obj, this);
        return col ? this : false;
      }
    });
  }
}

export default GameBoard;
// src/engine/core.js
import SpriteSheet from './sheet.js';
import GameBoard from './board.js';

const spriteSheet = new SpriteSheet();
const board = new GameBoard();
const baseInfo = {};

class Game {
  constructor() {
    this.KEY_CODES = {
      37: 'left',
      39: 'right',
      32: 'fire'
    };

    baseInfo.keys = this.keys = {};
    this.boards = [];
  }

  init(id, data, callback) {
    this.canvas = document.getElementById(id);
    baseInfo.width = this.width = this.canvas.width;
    baseInfo.height = this.height = this.canvas.height;

    this.ctx = this.canvas.getContext('2d');
    if (!this.ctx) {
      return alert('Please upgrade your browser to play');
    }

    this.setupInput();
    this.loop();

    spriteSheet.load(data, callback);
  }

  setupInput() {
    window.addEventListener('keydown', e => {
      if (this.KEY_CODES[e.keyCode]) {
        this.keys[this.KEY_CODES[e.keyCode]] = true;
        e.preventDefault();
      }
    });

    window.addEventListener('keyup', e => {
      if (this.KEY_CODES[e.keyCode]) {
        this.keys[this.KEY_CODES[e.keyCode]] = false;
        e.preventDefault();
      }
    });
  }

  loop() {
    const dt = 30 / 1000;
    const len = this.boards.length;
    for (let i = 0; i < len; i++) {
      if(this.boards[i]) {
        this.boards[i].step(dt);
        this.boards[i] && this.boards[i].draw(this.ctx);
      }
    }
    setTimeout(this.loop.bind(this), 30);
  }

  // Change an active game board
  setBoard(num, board) {
    this.boards[num] = board;
  }
}

export {
  spriteSheet,
  Game,
  baseInfo,
  board
};
// src/engine/enemy.js
import { baseInfo, board } from './core.js';
import Sprite from './sprite.js';
import { OBJECT_ENEMY } from './types.js';

class Eneny extends Sprite {
  constructor(blueprint, override) {
    super();
    this.para = { A: 0, B: 0, C: 0, D: 0,
      E: 0, F: 0, G: 0, H: 0, t: 0 };
    this.merge(this.para);
    this.setup(blueprint.sprite, blueprint);
    this.merge(override);
    this.type = OBJECT_ENEMY;
  }

  step(dt) {
    this.t += dt;
    this.vx = this.A + this.B * Math.sin(this.C * this.t + this.D);
    this.vy = this.E + this.F * Math.sin(this.G * this.t + this.H);

    this.x += this.vx * dt;
    this.y += this.vy * dt;

    if (this.y > baseInfo.height || this.x < -this.w ||
        this.x > baseInfo.width) {
      board.remove(this);
    }
  }
}

export default Eneny;
// src/engine/missile.js
import { board } from './core.js';
import Sprite from './sprite.js';
import { OBJECT_PLAYER_PROJECTILE, OBJECT_ENEMY } from './types.js';

class Missile extends Sprite {
  constructor(x, y) {
    super();
    this.setup('missile', { vy: -700, damage: 10 });
    this.x = x - this.w / 2;
    this.y = y - this.h;
    this.type = OBJECT_PLAYER_PROJECTILE;
  }

  step(dt) {
    this.y += this.vy * dt;
    const col = board.collide(this, OBJECT_ENEMY);
    if (col) {
      col.hit(this.damage);
      board.remove(this);
      console.log(board.removed);
    } else if (this.y < -this.h) {
      board.remove(this);
    }
  }
}

export default Missile;
// src/engine/player.js
import { spriteSheet, baseInfo, board } from './core.js';
import Missile from './missile.js';
import Sprite from './sprite.js';
import { OBJECT_PLAYER } from './types.js';

class Player extends Sprite {
  constructor() {
    super();
    this.setup('ship', {
      vx: 0, frame: 1, reloadTime: 0.25, maxVel: 200
    });

    this.type = OBJECT_PLAYER;
    this.x = baseInfo.width / 2 - this.w / 2;
    this.y = baseInfo.height - 10 - this.h;
    this.reload = this.reloadTime;

  }

  step(dt) {
    this.maxVel = 200;
    if (baseInfo.keys['left']) {
      this.vx = -this.maxVel;
    } else if (baseInfo.keys['right']) {
      this.vx = this.maxVel;
    } else {
      this.vx = 0;
    }

    this.x += this.vx * dt;

    if (this.x < 0) this.x = 0;
    if (this.x > baseInfo.width - this.w) {
      this.x = baseInfo.width - this.w;
    }

    // fire
    this.reload -= dt;
    if (baseInfo.keys['fire'] && this.reload < 0) {
      baseInfo.keys['fire'] = false;
      this.reload = this.reloadTime;
      board.add(new Missile(this.x, this.y + this.h/2));
      board.add(new Missile(this.x + this.w, this.y + this.h/2));
    }

  }
}

export default Player;
// engine/screen.js
import { baseInfo } from './core.js';

class TitleScreen {
  constructor(title, subtitle, callback) {
    this.title = title;
    this.subtitle = subtitle;
    this.callback = callback;
  }

  step(dt) {
    if(baseInfo.keys['fire'] && this.callback) this.callback();
  }

  draw(ctx) {
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';

    ctx.font = 'bold 40px Arial';
    ctx.fillText(this.title, baseInfo.width/2, baseInfo.height/2);

    ctx.font = 'bold 20px Arial';
    ctx.fillText(this.subtitle, baseInfo.width/2, baseInfo.height/2 + 40)
  }
}

export default TitleScreen;
// engine/sheet.js
import sprites from '../static/sprites.png';

class SpriteSheet {
  constructor() {
    this.map = {};
  }

  load(spriteData, callback) {
    this.map = spriteData;
    this.img = new Image();
    this.img.onload = callback;
    this.img.src = sprites;
  }

  draw(ctx, sprite, x, y, frame = 0) {
    const s = this.map[sprite];
    ctx.drawImage(this.img, s.sx + frame * s.w,
                  s.sy, s.w, s.h, x, y, s.w, s.h);
  }
}

export default SpriteSheet;
// engine/sprite.js
import { spriteSheet, board } from './core.js';

class Sprite {
  setup(sprite, props) {
    this.sprite = sprite;
    this.merge(props);
    this.frame = this.frame || 0;

    this.w = spriteSheet.map[sprite].w;
    this.h = spriteSheet.map[sprite].h;
  }

  merge(props) {
    if(props) {
      for (let prop in props) {
        this[prop] = props[prop];
      }
    }
  }

  draw(ctx) {
    spriteSheet.draw(ctx, this.sprite, this.x, this.y, this.frame);
  }

  hit(damage) {
    board.remove(this);
  }
}

export default Sprite;
// engine/starfield.js
import { baseInfo } from './core.js';

class Starfield {
  constructor(speed, opacity, numStars, clear) {
    this.stars = document.createElement("canvas");
    this.stars.width = baseInfo.width;
    this.stars.height = baseInfo.height;

    const starCtx = this.stars.getContext('2d');
    this.offset = 0;
    this.speed = speed;

    if (clear) {
      starCtx.fillStyle = '#000';
      starCtx.fillRect(0, 0, this.stars.width, this.stars.height);
    }

    starCtx.fillStyle = '#fff';
    starCtx.globalAlpha = opacity;
    for (let i = 0; i < numStars; i++) {
      starCtx.fillRect(Math.floor(Math.random() * this.stars.width),
        Math.floor(Math.random() * this.stars.height), 2, 2);
    }
  }

  draw(ctx) {
    const intOffset = Math.floor(this.offset);
    let remaining = this.stars.height - intOffset;
    if (intOffset > 0) {
      ctx.drawImage(this.stars, 0, remaining, this.stars.width, intOffset,
        0, 0, this.stars.width, intOffset);
    }

    if (remaining > 0) {
      ctx.drawImage(this.stars, 0, 0, this.stars.width, remaining,
        0, intOffset, this.stars.width, remaining);
    }
  }

  step(dt) {
    this.offset += dt * this.speed;
    this.offset = this.offset % this.stars.height;
  }
}

export default Starfield;
// engine/types.js
const OBJECT_PLAYER = 1,
      OBJECT_PLAYER_PROJECTILE = 2,
      OBJECT_ENEMY = 4,
      OBJECT_ENEMY_PROJECTILE = 8,
      OBJECT_POWERUP = 16;

export {
  OBJECT_PLAYER,
  OBJECT_PLAYER_PROJECTILE,
  OBJECT_ENEMY,
  OBJECT_ENEMY_PROJECTILE,
  OBJECT_POWERUP
}
//static/base.css
/* http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
*/
html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
  display: block;
}
body {
  line-height: 1;
}
ol, ul {
  list-style: none;
}
blockquote, q {
  quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
  content: '';
  content: none;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}

/* Center the constainer */
#container {
  padding-top: 50px;
  margin: 0 auto;
  width: 480px;
}

/* Give canvas a background */
canvas {
  background-color: black;
}
// index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Alien Invasion</title>
</head>
<body>
  <div id="container">
    <canvas id="game" width="320" height="480"></canvas>
  </div>
</body>
</html>
// index.js
import './static/base.css';
import { spriteSheet, Game, board } from './engine/core.js';
import Starfield from './engine/starfield.js';
import Screen from './engine/screen.js';
import Player from './engine/player.js';
import GameBoard from './engine/board.js';
import Enemy from './engine/enemy.js';

const sprites = {
  ship: { sx: 0, sy: 0, w: 37, h: 42, frame: 1 },
  missile: { sx: 0, sy: 30, w: 2, h: 10, frame: 1 },
  enemy_purple: { sx: 37, sy: 0, w: 42, h: 43, frame: 1 },
  enemy_bee: { sx: 79, sy: 0, w: 37, h: 43, frame: 1 },
  enemy_ship: { sx: 116, sy: 0, w: 42, h: 43, frame: 1 },
  enemy_circle: { sx: 158, sy: 0, w: 32, h: 33, frame: 1 },
};

const enemies = {
  basic: { x: 100, y: -50, sprite: 'enemy_purple', B: 100, C: 2, E: 100 }
};

const game = new Game();
const startGame = () => {
  game.setBoard(0, new Starfield(20, 0.4, 100, true));
  game.setBoard(1, new Starfield(50, 0.6, 100));
  game.setBoard(2, new Starfield(100, 1.0, 50));
  game.setBoard(3, new Screen('Alien Invasion',
    'Press space to start playing', playGame));
}

const playGame = () => {
  // add enemy
  board.add(new Enemy(enemies.basic));
  board.add(new Enemy(enemies.basic, { x: 200 }));

  // add player
  board.add(new Player());
  game.setBoard(3, board);
}

window.addEventListener('load', () => {
  game.init('game', sprites, startGame);
})
// .eslintrc
{
  "parser": "babel-eslint",
  "extends": "eslint:recommended",
  "env": {
    "browser": true,
    "es6": true
  },
  "rules": {
    "no-console": "warn"
  }
}
// package.json
{
  "name": "alien-invasion",
  "version": "1.0.0",
  "description": "a top-down 2D shooter game built with html5 canvas",
  "main": "phecs.js",
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "build": "webpack",
    "dev": "webpack-dev-server",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "babel-core": "^6.25.0",
    "babel-eslint": "^7.2.3",
    "babel-loader": "^7.1.1",
    "babel-preset-es2015": "^6.24.1",
    "css-loader": "^0.28.4",
    "eslint": "^4.2.0",
    "eslint-loader": "^1.9.0",
    "extract-text-webpack-plugin": "^3.0.0",
    "html-webpack-plugin": "^2.29.0",
    "style-loader": "^0.18.2",
    "url-loader": "^0.5.9",
    "webpack": "^3.3.0",
    "webpack-dev-server": "^2.5.1"
  }
}
// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const webpack = require('webpack');

module.exports = {
  entry: path.resolve(__dirname, 'src/index.js'),
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'game.min.js'
  },

  module: {
    loaders: [{
      test: /\.js$/,
      exclude: /node_modules/,
      loader: ['babel-loader', 'eslint-loader']
    }],

    rules: [
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
          fallback: "style-loader",
          use: "css-loader"
        })
      },

      {
        test: /\.(png|jpg|gif)$/,
        use: [
          {
            loader: 'url-loader'
          }
        ]
      }
    ]
  },

  devServer: {
    hot: true,
    publicPath: 'src/static/'
  },

  plugins: [
    new ExtractTextPlugin("style.css"),
    new HtmlWebpackPlugin({
      template: 'src/index.html',
      inject: 'body'
    }),

    new webpack.HotModuleReplacementPlugin()
  ]
}
