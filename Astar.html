<button>find path</button>
<canvas id="canvas"></canvas>
<script type="text/javascript">
  class Astar {
    constructor () {
      this.myMap = [
        '0000000',
        '0111000',
        '0001000',
        '0201000',
        '1111030',
        '0000000',
      ];
      this.startPoint = {x: 3, y: 1};
      this.endPoint = {x: 4, y: 5};
      this.openList = [];
      this.closeList = [];
      this.UNIT = 30;
      this.CELL = 32;
      // up, right, down, left
      this.offset = [{x: -1, y: 0}, {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}];
      this.isOver = false;
      this.status = '';

      this.setupMap();
      this.drawMap();
    }

    setupMap () {
      const size = {
        row: this.myMap.length,
        col: this.myMap[0].length,
      }
      // set up canvas
      const canvas = document.getElementById('canvas');
      canvas.width = size.col * this.CELL + this.CELL - this.UNIT;
      canvas.height = size.row * this.CELL + this.CELL - this.UNIT;

      this.ctx = canvas.getContext('2d');
      this.ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    drawMap () {
      this.myMap.map((str, i) => {
        str.split('').forEach((fill, j) => {
          switch (fill) {
            case '0':
              this.ctx.fillStyle = '#f3f3f3';
              break;
            case '1':
              // wall
              this.ctx.fillStyle = '#000000';
              break;
            case '2':
              // start point
              this.ctx.fillStyle = '#ff0000';
              break;
            case '3':
              // end point
              this.ctx.fillStyle = '#0000ff';
              break;
            default:
              break;
          }

          this.ctx.fillRect(
            j * this.CELL + (this.CELL - this.UNIT),
            i * this.CELL + (this.CELL - this.UNIT),
            this.UNIT,
            this.UNIT
          );
        });
      });
    }

    navigate () {
      this.currentPoint = this.startPoint;
      do {
        this.closeList.push(this.currentPoint);
        this.checkAround(this.currentPoint);

        if (this.openList.length === 0) {
          this.isOver = true;
          this.status = 'fail';
        }

        if (this.isOver) {
          console.log(`navigate ${this.status}!`);
          break;
        }

        let FList = [];
        this.openList.map((item, i) => {
          // find the floor F value
          FList[i] = this.getF(item);
        });

        let index = this.getMinIndex(FList);
        let minList = [];
        let i = 0, currentIndex;
        if (index.length > 1) {
          index.map((item, i) => {
            minList[i] = this.distance(this.openList[item]);
          });

          const tmp = this.getMinIndex(minList);
          i = tmp[0];
        }

        currentIndex = index[i];
        this.currentPoint = this.openList[currentIndex];
        this.openList.splice(currentIndex, 1);

      } while (this.openList)

    }

    checkAround (point) {
      for (let i = 0; i < 4; i++) {
        const tmp = this.calc(point, i);

        // the checked point beyond boundary || attach wall || already in open/close List
        if (!this.myMap[tmp.x] || !this.myMap[tmp.x][tmp.y] ||this.myMap[tmp.x][tmp.y] === '1'
              || this.isInList(tmp, this.closeList) || this.isInList(tmp, this.openList)) {
          continue;
        }

        // find the endpoint
        if (tmp.x === this.endPoint.x && tmp.y === this.endPoint.y) {
          this.isOver = true;
          this.status = 'success';

          const pathArr = [];
          let tmp = this.closeList[this.closeList.length - 1];
          while (tmp.parent) {
            pathArr.push(tmp);
            tmp = tmp.parent;
          }

          pathArr.reverse();
          pathArr.map((item, i) => {
            let timer = null;
            timer = setTimeout(() => {
              this.drawPath(item);
              clearTimeout(timer);
            }, i * 100);
          });

          break;
        }

        tmp.parent = point;
        this.openList.push(tmp);
      }
    }

    getF (point) {
      const G = Math.abs(this.startPoint.x - point.x) + Math.abs(this.startPoint.y - point.y);
      const H = Math.abs(this.endPoint.x - point.x) + Math.abs(this.endPoint.y - point.y);
      return G + H;
    }
    // get the distance of current point and checked point
    distance (point) {
      return Math.abs(this.currentPoint.x - point.x) + Math.abs(this.currentPoint.y - point.y);
    }

    // return index array or an index
    getMinIndex (arr) {
      let valueList= [];
      const min = Math.min(...arr);
      arr.map((item, i) => {
        if (item === min) {
          valueList.push(i);
        }
      });

      return valueList;
    }

    // add the offset value for current point
    calc (point, i) {
      if (this.offset[i]) {
        return {
          x: point.x + this.offset[i].x,
          y: point.y + this.offset[i].y,
        }
      }
    }

    drawPath (point) {
      this.ctx.fillStyle = '#00ff00';
      this.ctx.fillRect(
        point.y * this.CELL + (this.CELL - this.UNIT),
        point.x * this.CELL + (this.CELL - this.UNIT),
        this.UNIT,
        this.UNIT);
    }

    isInList(point, list) {
      let tmp;
      list.map((item) => {
        if (item.x === point.x && item.y === point.y) {
          tmp = true;
        }
      });
      return tmp;
    }
  }

  var app = new Astar();
  document.getElementsByTagName('button')[0].onclick = () => {
    app.navigate();
  }
</script>
